# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
# pylint: disable=redefined-outer-name
# pylint: disable=unused-argument
# pylint: disable=protected-access
import asyncio
import datetime
import json
import time
from collections.abc import Collection
from collections.abc import Iterator
from typing import Any
from unittest.mock import ANY
from unittest.mock import AsyncMock
from unittest.mock import MagicMock
from unittest.mock import patch
from uuid import UUID
from uuid import uuid4

import pytest
from fastapi.encoders import jsonable_encoder
from fastramqpi.context import Context
from freezegun import freeze_time
from httpx import Response
from ldap3.core.exceptions import LDAPInvalidValueError
from more_itertools import one
from pydantic import BaseModel
from pydantic import Field
from pydantic import parse_obj_as
from ramodels.mo.details.address import AddressType
from structlog.testing import capture_logs

from mo_ldap_import_export.autogenerated_graphql_client.class_create import (
    ClassCreateClassCreate,
)
from mo_ldap_import_export.autogenerated_graphql_client.client import GraphQLClient
from mo_ldap_import_export.autogenerated_graphql_client.read_class_uuid import (
    ReadClassUuidClasses,
)
from mo_ldap_import_export.autogenerated_graphql_client.read_class_uuid import (
    ReadClassUuidClassesObjects,
)
from mo_ldap_import_export.autogenerated_graphql_client.read_employee_uuid_by_cpr_number import (
    ReadEmployeeUuidByCprNumberEmployees,
)
from mo_ldap_import_export.autogenerated_graphql_client.read_employee_uuid_by_ituser_user_key import (
    ReadEmployeeUuidByItuserUserKeyItusers,
)
from mo_ldap_import_export.autogenerated_graphql_client.read_facet_uuid import (
    ReadFacetUuidFacets,
)
from mo_ldap_import_export.config import Settings
from mo_ldap_import_export.dataloaders import DN
from mo_ldap_import_export.dataloaders import DataLoader
from mo_ldap_import_export.dataloaders import Verb
from mo_ldap_import_export.environments import get_or_create_engagement_type_uuid
from mo_ldap_import_export.environments import get_or_create_job_function_uuid
from mo_ldap_import_export.environments import load_mo_root_org_uuid
from mo_ldap_import_export.exceptions import DNNotFound
from mo_ldap_import_export.exceptions import MultipleObjectsReturnedException
from mo_ldap_import_export.exceptions import NoObjectsReturnedException
from mo_ldap_import_export.exceptions import ReadOnlyException
from mo_ldap_import_export.ldap_classes import LdapObject
from mo_ldap_import_export.ldapapi import LDAPAPI
from mo_ldap_import_export.moapi import extract_current_or_latest_validity
from mo_ldap_import_export.models import Address
from mo_ldap_import_export.models import Employee
from mo_ldap_import_export.models import ITUser
from mo_ldap_import_export.models import Validity
from mo_ldap_import_export.routes import load_all_current_it_users
from mo_ldap_import_export.routes import load_ldap_attribute_values
from mo_ldap_import_export.routes import load_ldap_cpr_object
from mo_ldap_import_export.routes import load_ldap_objects
from mo_ldap_import_export.types import CPRNumber
from mo_ldap_import_export.types import OrgUnitUUID
from tests.graphql_mocker import GraphQLMocker


@pytest.fixture()
def ldap_attributes() -> dict:
    return {
        "department": None,
        "name": "John",
        "employeeID": "0101011234",
        "postalAddress": "foo",
    }


@pytest.fixture
def cpr_field() -> str:
    return "employeeID"


@pytest.fixture
def ldap_connection() -> Iterator[MagicMock]:
    """Fixture to construct a mock ldap_connection.

    Yields:
        A mock for ldap_connection.
    """
    ldap_connection = MagicMock()
    yield ldap_connection


@pytest.fixture
def legacy_graphql_session() -> Iterator[AsyncMock]:
    yield AsyncMock()


@pytest.fixture
def graphql_client() -> Iterator[AsyncMock]:
    yield AsyncMock()


@pytest.fixture
def settings(minimal_mapping: dict[str, Any], monkeypatch: pytest.MonkeyPatch):
    monkeypatch.setenv("CONVERSION_MAPPING", json.dumps(minimal_mapping))
    monkeypatch.setenv("CLIENT_ID", "foo")
    monkeypatch.setenv("CLIENT_SECRET", "bar")
    monkeypatch.setenv("LDAP_CONTROLLERS", '[{"host": "0.0.0.0"}]')
    monkeypatch.setenv("LDAP_DOMAIN", "LDAP")
    monkeypatch.setenv("LDAP_USER", "foo")
    monkeypatch.setenv("LDAP_PASSWORD", "bar")
    monkeypatch.setenv("LDAP_SEARCH_BASE", "DC=ad,DC=addev")
    monkeypatch.setenv("LDAP_OBJECT_CLASS", "inetOrgPerson")
    monkeypatch.setenv("LDAP_CPR_ATTRIBUTE", "employeeID")
    monkeypatch.setenv("DEFAULT_ORG_UNIT_LEVEL", "foo")
    monkeypatch.setenv("DEFAULT_ORG_UNIT_TYPE", "foo")
    monkeypatch.setenv("LDAP_OUS_TO_WRITE_TO", '[""]')
    monkeypatch.setenv("FASTRAMQPI__AMQP__URL", "amqp://guest:guest@msg_broker:5672/")
    monkeypatch.setenv("INTERNAL_AMQP__URL", "amqp://guest:guest@msg_broker:5672/")

    return Settings()


@pytest.fixture
def converter() -> MagicMock:
    converter_mock = MagicMock()
    converter_mock.find_ldap_object_class.return_value = "user"
    return converter_mock


@pytest.fixture
def username_generator() -> MagicMock:
    return AsyncMock()


@pytest.fixture
def sync_tool() -> AsyncMock:
    sync_tool = AsyncMock()
    return sync_tool


@pytest.fixture
def dataloader(
    ldap_connection: MagicMock,
    legacy_graphql_session: AsyncMock,
    graphql_client: AsyncMock,
    settings: Settings,
    converter: MagicMock,
    sync_tool: AsyncMock,
    username_generator: MagicMock,
) -> DataLoader:
    """Fixture to construct a dataloaders object using fixture mocks.

    Yields:
        Dataloaders with mocked clients.
    """
    context: Context = {
        "legacy_graphql_session": legacy_graphql_session,
        "graphql_client": graphql_client,
        "user_context": {
            "settings": settings,
            "ldap_connection": ldap_connection,
            "converter": converter,
            "sync_tool": sync_tool,
            "username_generator": username_generator,
        },
    }
    amqpsystem = AsyncMock()
    return DataLoader(context, amqpsystem)


@pytest.fixture
def graphql_mock(dataloader, respx_mock) -> Iterator[GraphQLMocker]:
    dataloader.context["graphql_client"] = GraphQLClient("http://example.com/graphql")

    yield GraphQLMocker(respx_mock)


def mock_ldap_response(ldap_attributes: dict, dn: DN) -> dict[str, Collection[str]]:
    expected_attributes = ldap_attributes.keys()
    inner_dict = ldap_attributes

    for attribute in expected_attributes:
        if attribute not in inner_dict:
            inner_dict[attribute] = None

    response = {"dn": dn, "type": "searchResEntry", "attributes": inner_dict}

    return response


async def test_load_ldap_cpr_object(
    ldap_connection: MagicMock,
    dataloader: DataLoader,
    ldap_attributes: dict,
    monkeypatch: pytest.MonkeyPatch,
) -> None:
    # Mock data
    dn = "CN=Nick Janssen,OU=Users,OU=Magenta,DC=ad,DC=addev"

    expected_result = LdapObject(dn=dn, **ldap_attributes)
    ldap_connection.get_response.return_value = (
        [mock_ldap_response(ldap_attributes, dn)],
        {"type": "test"},
    )

    output = one(
        await load_ldap_cpr_object(dataloader, CPRNumber("0101012002"), "Employee")
    )
    assert output == expected_result

    with pytest.raises(NoObjectsReturnedException):
        await load_ldap_cpr_object(dataloader, "__invalid__", "Employee")  # type: ignore

    with pytest.raises(NoObjectsReturnedException):
        monkeypatch.delenv("LDAP_CPR_ATTRIBUTE")
        monkeypatch.setenv("LDAP_IT_SYSTEM", "ADUUID")
        dataloader.settings = Settings()
        await load_ldap_cpr_object(dataloader, CPRNumber("0101012002"), "Employee")


async def test_load_ldap_objects(
    ldap_connection: MagicMock, dataloader: DataLoader, ldap_attributes: dict
) -> None:
    dn = "CN=Nick Janssen,OU=Users,OU=Magenta,DC=ad,DC=addev"
    expected_result = [LdapObject(dn=dn, **ldap_attributes)] * 2
    ldap_connection.get_response.return_value = (
        [mock_ldap_response(ldap_attributes, dn)] * 2,
        {"type": "test", "description": "success"},
    )
    settings = dataloader.settings
    converter = dataloader.converter
    output = await load_ldap_objects(settings, ldap_connection, converter, "Employee")

    assert output == expected_result


async def test_upload_ldap_object_invalid_value(
    ldap_connection: MagicMock,
    dataloader: DataLoader,
) -> None:
    dataloader.ldap_connection.get_response.return_value = (
        [],
        {"type": "test", "description": "compareFalse"},
    )

    dn = "CN=Nick Janssen,OU=Users,OU=Magenta,DC=ad,DC=addev"

    ldap_connection.modify.side_effect = LDAPInvalidValueError("Invalid value")

    with pytest.raises(LDAPInvalidValueError) as exc_info:
        await dataloader.ldapapi.modify_ldap_object(dn, {})
    assert "Invalid value" in str(exc_info.value)


@pytest.mark.usefixtures("minimal_valid_environmental_variables")
async def test_modify_ldap_object_read_only(
    dataloader: DataLoader,
    monkeypatch: pytest.MonkeyPatch,
) -> None:
    monkeypatch.setenv("LDAP_READ_ONLY", "True")
    dataloader.ldapapi.settings = Settings()

    with pytest.raises(ReadOnlyException) as exc_info:
        await dataloader.ldapapi.modify_ldap_object("CN=Foo", {})
    assert "LDAP connection is read-only" in str(exc_info.value)


@pytest.mark.usefixtures("minimal_valid_environmental_variables")
async def test_modify_ldap_object_invalid_ou(
    dataloader: DataLoader,
    monkeypatch: pytest.MonkeyPatch,
) -> None:
    monkeypatch.setenv("LDAP_OUS_TO_WRITE_TO", '["OU=non-existent"]')
    settings = Settings()

    dataloader.settings = settings
    dataloader.ldapapi = LDAPAPI(settings, dataloader.ldap_connection)

    dn = "UID=abk,OU=os2mo,O=magenta,DC=magenta,DC=dk"
    with capture_logs() as cap_logs:
        await dataloader.ldapapi.modify_ldap_object(dn, {})
    messages = [w["event"] for w in cap_logs]
    assert messages == [
        "Uploading object",
        "OU not in OUs to write",
        "Not allowed to write to the specified OU",
    ]


async def test_load_mo_employee(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    cpr_no = "1407711900"
    uuid = uuid4()

    employee = {
        "uuid": uuid,
        "cpr_no": cpr_no,
        "givenname": "first_name",
        "surname": "last_name",
        "nickname_givenname": None,
        "nickname_surname": None,
        "validity": {"to": None},
    }

    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": [{"validities": [employee]}]}}

    employee.pop("validity")
    expected_result = Employee(**employee)

    output = await dataloader.moapi.load_mo_employee(uuid)
    assert output == expected_result
    assert route.called


async def test_load_mo_employee_no_objects(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    uuid = uuid4()

    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": []}}

    result = await dataloader.moapi.load_mo_employee(uuid)
    assert result is None
    assert route.called


async def test_load_mo_employee_no_validities(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    uuid = uuid4()

    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": [{"validities": []}]}}

    result = await dataloader.moapi.load_mo_employee(uuid)
    assert result is None
    assert route.called


@pytest.mark.parametrize(
    "objects",
    [
        # No objects returned
        [],
        # Object returned, but no validities
        [{"validities": []}],
    ],
)
async def test_load_mo_address_not_found(
    dataloader: DataLoader, graphql_mock: GraphQLMocker, objects: list[dict]
) -> None:
    route = graphql_mock.query("read_addresses")
    route.result = {"addresses": {"objects": objects}}

    result = await dataloader.moapi.load_mo_address(uuid4())
    assert result is None

    assert route.called


async def test_load_mo_address(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    uuid = uuid4()

    address_dict: dict = {
        "value": "foo@bar.dk",
        "uuid": uuid,
        "address_type": {"uuid": uuid},
        "validity": {"from": "2021-01-01T01:00:00Z", "to": None},
        "person": {"uuid": uuid},
        "org_unit": {"uuid": uuid},
        "visibility": {"uuid": uuid},
        "engagement": {"uuid": uuid},
    }

    # Note that 'Address' requires 'person' to be a dict
    expected_result = Address(**address_dict.copy())

    # While graphQL returns it as a list with length 1
    address_dict["person"] = [{"cpr_no": "0101012002"}]
    address_dict["address_type"]["user_key"] = "address"
    address_dict["value2"] = None
    address_dict["visibility_uuid"] = uuid
    address_dict["employee_uuid"] = uuid
    address_dict["org_unit_uuid"] = uuid
    address_dict["engagement_uuid"] = uuid

    route = graphql_mock.query("read_addresses")
    route.result = {"addresses": {"objects": [{"validities": [address_dict]}]}}

    output = await dataloader.moapi.load_mo_address(uuid)
    assert output == expected_result


async def test_load_mo_employee_addresses(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    address_uuid = uuid4()
    address_type_uuid = uuid4()

    route = graphql_mock.query("read_employee_addresses")
    route.result = {
        "addresses": {
            "objects": [
                {
                    "uuid": address_uuid,
                    "validities": [
                        {
                            "value": "Test",
                            "uuid": address_uuid,
                            "validity": {"from": "1900-01-01T00:00:00"},
                            "address_type": {
                                "user_key": "postalAddress",
                                "uuid": address_type_uuid,
                            },
                        }
                    ],
                }
            ]
        }
    }

    employee_uuid = uuid4()
    result = await dataloader.moapi.load_mo_employee_addresses(
        employee_uuid, address_type_uuid
    )
    assert result == [
        Address(
            type_="address",
            uuid=address_uuid,
            user_key=str(address_uuid),
            value="Test",
            address_type=AddressType(uuid=address_type_uuid),
            validity=Validity(from_date=datetime.datetime(1900, 1, 1, 0, 0)),
        )
    ]

    assert route.called


async def test_load_mo_employee_addresses_not_found(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    route = graphql_mock.query("read_employee_addresses")
    route.result = {"addresses": {"objects": []}}

    employee_uuid = uuid4()
    address_type_uuid = uuid4()
    result = await dataloader.moapi.load_mo_employee_addresses(
        employee_uuid, address_type_uuid
    )
    assert result == []

    assert route.called


async def test_load_mo_employee_addresses_not_validity(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    address_uuid = uuid4()

    route = graphql_mock.query("read_employee_addresses")
    route.result = {
        "addresses": {"objects": [{"uuid": address_uuid, "validities": []}]}
    }

    employee_uuid = uuid4()
    address_type_uuid = uuid4()
    with capture_logs() as cap_logs:
        result = await dataloader.moapi.load_mo_employee_addresses(
            employee_uuid, address_type_uuid
        )
        assert result == []
    assert cap_logs == [
        {
            "event": "Unable to lookup employee addresses",
            "log_level": "warning",
            "uuids": [address_uuid],
        }
    ]

    assert route.called


def mock_read_employee_uuid_by_cpr_number(
    dataloader: DataLoader, values: list[UUID]
) -> None:
    dataloader.graphql_client.read_employee_uuid_by_cpr_number.return_value = (  # type: ignore
        parse_obj_as(
            ReadEmployeeUuidByCprNumberEmployees,
            {"objects": [{"uuid": uuid} for uuid in values]},
        )
    )


def mock_read_employee_uuid_by_ituser(
    dataloader: DataLoader, values: list[UUID]
) -> None:
    dataloader.graphql_client.read_employee_uuid_by_ituser_user_key.return_value = (  # type: ignore
        parse_obj_as(
            ReadEmployeeUuidByItuserUserKeyItusers,
            {"objects": [{"current": {"employee_uuid": uuid}} for uuid in values]},
        )
    )


async def test_find_mo_employee_uuid_by_cpr_number(dataloader: DataLoader):
    uuid = uuid4()

    ldap_object = LdapObject(
        dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
    )

    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object", return_value=ldap_object
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [uuid])
        mock_read_employee_uuid_by_ituser(dataloader, [])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output == uuid


async def test_find_mo_employee_uuid_by_ituser(dataloader: DataLoader):
    uuid = uuid4()

    ldap_object = LdapObject(dn="CN=foo", employeeID="Ja", objectGUID=str(uuid4()))
    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object", return_value=ldap_object
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [])
        mock_read_employee_uuid_by_ituser(dataloader, [uuid])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output == uuid


async def test_find_mo_employee_uuid_fallback_ituser(
    dataloader: DataLoader, monkeypatch: pytest.MonkeyPatch
) -> None:
    monkeypatch.delenv("LDAP_CPR_ATTRIBUTE")
    monkeypatch.setenv("LDAP_IT_SYSTEM", "ADUUID")
    dataloader.settings = Settings()
    dataloader.ldapapi.settings = Settings()

    uuid1 = uuid4()
    uuid2 = uuid4()

    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object",
        return_value=LdapObject(
            dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
        ),
    ):
        # There is a CPR match, but it is not configured, so we get the ITUser match
        mock_read_employee_uuid_by_cpr_number(dataloader, [uuid1])
        mock_read_employee_uuid_by_ituser(dataloader, [uuid2])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output == uuid2


async def test_find_mo_employee_uuid_not_found(dataloader: DataLoader):
    ldap_object = LdapObject(
        dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
    )
    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object", return_value=ldap_object
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [])
        mock_read_employee_uuid_by_ituser(dataloader, [])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output is None


async def test_find_mo_employee_uuid_cpr_number_multiple_matches(
    dataloader: DataLoader,
):
    ldap_object = LdapObject(
        dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
    )
    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object", return_value=ldap_object
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [uuid4(), uuid4()])
        mock_read_employee_uuid_by_ituser(dataloader, [])
        with pytest.raises(MultipleObjectsReturnedException):
            await dataloader.find_mo_employee_uuid("CN=foo")


async def test_find_mo_employee_uuid_ituser_multiple_matches(dataloader: DataLoader):
    ldap_object = LdapObject(
        dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
    )
    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object", return_value=ldap_object
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [])
        mock_read_employee_uuid_by_ituser(dataloader, [uuid4(), uuid4()])
        with pytest.raises(MultipleObjectsReturnedException):
            await dataloader.find_mo_employee_uuid("CN=foo")


async def test_find_mo_employee_uuid_multiple_matches(dataloader: DataLoader):
    uuid1 = uuid4()
    uuid2 = uuid4()

    ldap_object = LdapObject(
        dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
    )
    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object", return_value=ldap_object
    ):
        # We never actually check ituser, due to early return
        mock_read_employee_uuid_by_cpr_number(dataloader, [uuid1])
        mock_read_employee_uuid_by_ituser(dataloader, [uuid2])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output == uuid1


async def test_load_mo_employee_not_found(
    dataloader: DataLoader, legacy_graphql_session: AsyncMock
):
    legacy_graphql_session.execute.return_value = {"employees": {"objects": []}}

    uuid = uuid4()

    result = await dataloader.moapi.load_mo_employee(uuid)
    assert result is None


async def test_load_mo_it_user(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    uuid1 = uuid4()
    uuid2 = uuid4()

    route = graphql_mock.query("read_itusers")
    route.result = {
        "itusers": {
            "objects": [
                {
                    "validities": [
                        {
                            "user_key": "foo",
                            "validity": {"from": "2021-01-01T00:00:00", "to": None},
                            "employee_uuid": uuid1,
                            "itsystem_uuid": uuid2,
                            "engagement_uuid": uuid1,
                        }
                    ]
                }
            ]
        }
    }

    output = await dataloader.moapi.load_mo_it_user(uuid4())
    assert output is not None
    assert output.user_key == "foo"
    assert output.itsystem.uuid == uuid2
    assert output.person.uuid == uuid1  # type: ignore
    assert output.engagement.uuid == uuid1  # type: ignore
    assert output.validity.from_date.strftime("%Y-%m-%d") == "2021-01-01"

    assert route.called


async def test_load_mo_engagement(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    route = graphql_mock.query("read_engagements")
    route.result = {
        "engagements": {
            "objects": [
                {
                    "validities": [
                        {
                            "user_key": "foo",
                            "validity": {"from": "2021-01-01T00:00:00", "to": None},
                            "extension_1": "extra info",
                            "extension_2": "more extra info",
                            "extension_3": None,
                            "extension_4": None,
                            "extension_5": None,
                            "extension_6": None,
                            "extension_7": None,
                            "extension_8": None,
                            "extension_9": None,
                            "extension_10": None,
                            "leave_uuid": uuid4(),
                            "primary_uuid": uuid4(),
                            "job_function_uuid": uuid4(),
                            "org_unit_uuid": uuid4(),
                            "engagement_type_uuid": uuid4(),
                            "employee_uuid": uuid4(),
                        }
                    ]
                }
            ]
        }
    }

    output = await dataloader.moapi.load_mo_engagement(uuid4())
    assert output is not None
    assert output.user_key == "foo"
    assert output.validity.from_date.strftime("%Y-%m-%d") == "2021-01-01"
    assert output.extension_1 == "extra info"
    assert output.extension_2 == "more extra info"

    assert route.called


@pytest.mark.parametrize(
    "objects",
    [
        # No objects returned
        [],
        # Object returned, but no validities
        [{"validities": []}],
    ],
)
async def test_load_mo_engagement_not_found(
    dataloader: DataLoader, graphql_mock: GraphQLMocker, objects: list[dict]
) -> None:
    route = graphql_mock.query("read_engagements")
    route.result = {"engagements": {"objects": objects}}

    result = await dataloader.moapi.load_mo_engagement(uuid4())
    assert result is None

    assert route.called


@pytest.mark.parametrize(
    "objects",
    [
        # No objects returned
        [],
        # Object returned, but no validities
        [{"validities": []}],
    ],
)
async def test_load_mo_it_user_not_found(
    dataloader: DataLoader, graphql_mock: GraphQLMocker, objects: list[dict]
) -> None:
    route = graphql_mock.query("read_itusers")
    route.result = {"itusers": {"objects": objects}}

    result = await dataloader.moapi.load_mo_it_user(uuid4())
    assert result is None

    assert route.called


async def test_load_mo_employee_it_users(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    ituser_uuid = uuid4()

    route1 = graphql_mock.query("read_ituser_by_employee_and_itsystem_uuid")
    route1.result = {"itusers": {"objects": [{"uuid": ituser_uuid}]}}

    user_key = "test"
    itsystem_uuid = uuid4()
    person_uuid = uuid4()
    route2 = graphql_mock.query("read_itusers")
    route2.result = {
        "itusers": {
            "objects": [
                {
                    "validities": [
                        {
                            "user_key": user_key,
                            "validity": {"from": "1970-01-01T00:00:00Z", "to": None},
                            "employee_uuid": person_uuid,
                            "itsystem_uuid": itsystem_uuid,
                            "engagement_uuid": None,
                        }
                    ]
                }
            ]
        }
    }

    employee_uuid = uuid4()
    it_system_uuid = uuid4()
    result = await dataloader.moapi.load_mo_employee_it_users(
        employee_uuid, it_system_uuid
    )
    assert one(result).dict() == {
        "user_key": user_key,
        "person": {"uuid": person_uuid},
        "itsystem": {"uuid": itsystem_uuid},
        "engagement": None,
        "org_unit": None,
        "type_": "it",
        "uuid": ANY,
        "validity": {
            "from_date": datetime.datetime(1970, 1, 1, tzinfo=datetime.UTC),
            "to_date": None,
        },
    }

    assert route1.called
    assert route2.called


async def test_load_mo_employee_it_users_not_found(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    route = graphql_mock.query("read_ituser_by_employee_and_itsystem_uuid")
    route.result = {"itusers": {"objects": []}}

    employee_uuid = uuid4()
    it_system_uuid = uuid4()
    result = await dataloader.moapi.load_mo_employee_it_users(
        employee_uuid, it_system_uuid
    )
    assert result == []

    assert route.called


async def test_load_mo_org_unit_addresses(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
):
    address_uuid = uuid4()
    address_type_uuid = uuid4()

    route = graphql_mock.query("read_org_unit_addresses")
    route.result = {
        "addresses": {
            "objects": [
                {
                    "uuid": address_uuid,
                    "validities": [
                        {
                            "value": "Test",
                            "uuid": address_uuid,
                            "validity": {"from": "1900-01-01T00:00:00"},
                            "address_type": {
                                "user_key": "postalAddress",
                                "uuid": address_type_uuid,
                            },
                        }
                    ],
                }
            ]
        }
    }

    org_unit_uuid = uuid4()
    result = await dataloader.moapi.load_mo_org_unit_addresses(
        OrgUnitUUID(org_unit_uuid), address_type_uuid
    )
    assert result == [
        Address(
            type_="address",
            uuid=address_uuid,
            user_key=str(address_uuid),
            value="Test",
            address_type=AddressType(uuid=address_type_uuid),
            validity=Validity(from_date=datetime.datetime(1900, 1, 1, 0, 0)),
        )
    ]

    assert route.called


async def test_load_mo_org_unit_addresses_not_found(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    route = graphql_mock.query("read_org_unit_addresses")
    route.result = {"addresses": {"objects": []}}

    employee_uuid = uuid4()
    address_type_uuid = uuid4()
    result = await dataloader.moapi.load_mo_org_unit_addresses(
        OrgUnitUUID(employee_uuid), address_type_uuid
    )
    assert result == []

    assert route.called


async def test_load_mo_org_unit_addresses_no_validity(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    address_uuid = uuid4()

    route = graphql_mock.query("read_org_unit_addresses")
    route.result = {
        "addresses": {"objects": [{"uuid": address_uuid, "validities": []}]}
    }

    employee_uuid = uuid4()
    address_type_uuid = uuid4()
    with capture_logs() as cap_logs:
        result = await dataloader.moapi.load_mo_org_unit_addresses(
            OrgUnitUUID(employee_uuid), address_type_uuid
        )
        assert result == []
    assert cap_logs == [
        {
            "event": "Unable to lookup org-unit addresses",
            "log_level": "warning",
            "uuids": [address_uuid],
        }
    ]

    assert route.called


async def test_load_mo_employee_engagements(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    uuid1 = uuid4()

    route1 = graphql_mock.query("read_engagements_by_employee_uuid")
    route1.result = {
        "engagements": {
            "objects": [
                {
                    "current": {
                        "uuid": uuid1,
                        "validity": {"from": "2020-01-01T00:00:00"},
                    }
                }
            ]
        }
    }

    user_key = "test"
    job_function_uuid = uuid4()
    org_unit_uuid = uuid4()
    engagement_type_uuid = uuid4()
    person_uuid = uuid4()
    route2 = graphql_mock.query("read_engagements")
    route2.result = {
        "engagements": {
            "objects": [
                {
                    "validities": [
                        {
                            "user_key": user_key,
                            "job_function_uuid": job_function_uuid,
                            "org_unit_uuid": org_unit_uuid,
                            "engagement_type_uuid": engagement_type_uuid,
                            "employee_uuid": person_uuid,
                            "validity": {"from": "2020-01-01T00:00:00Z"},
                        }
                    ]
                }
            ]
        }
    }

    result = await dataloader.moapi.load_mo_employee_engagements(person_uuid)
    assert one(result).dict(exclude_none=True) == {
        "engagement_type": {"uuid": engagement_type_uuid},
        "job_function": {"uuid": job_function_uuid},
        "org_unit": {"uuid": org_unit_uuid},
        "person": {"uuid": person_uuid},
        "type_": "engagement",
        "user_key": user_key,
        "uuid": ANY,
        "validity": {"from_date": datetime.datetime(2020, 1, 1, tzinfo=datetime.UTC)},
    }

    assert route1.called
    assert route2.called


@pytest.mark.parametrize(
    "engagement_uuids,results,expected",
    [
        # Zero UUIDs requested
        # ------------------
        # No uuids to lookup, should be early returned
        ([], [], []),
        # One UUID requested
        # ------------------
        # Base case, one reply (ours), primary and non-primary respectively
        (
            ["085bef5d-f435-4fe1-89d6-3d0f6b72d8e8"],
            [
                {
                    "current": {
                        "is_primary": True,
                        "uuid": "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                    }
                }
            ],
            [True],
        ),
        (
            ["085bef5d-f435-4fe1-89d6-3d0f6b72d8e8"],
            [
                {
                    "current": {
                        "is_primary": False,
                        "uuid": "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                    }
                }
            ],
            [False],
        ),
        # No results at all
        (["085bef5d-f435-4fe1-89d6-3d0f6b72d8e8"], [], [False]),
        # No current results
        (["085bef5d-f435-4fe1-89d6-3d0f6b72d8e8"], [{"current": None}], [False]),
        # Multiple non-current results
        (
            ["085bef5d-f435-4fe1-89d6-3d0f6b72d8e8"],
            [{"current": None}, {"current": None}],
            [False],
        ),
        # Multiple unrelated results
        (
            ["085bef5d-f435-4fe1-89d6-3d0f6b72d8e8"],
            [
                {"current": {"is_primary": True, "uuid": uuid4()}},
                {"current": {"is_primary": True, "uuid": uuid4()}},
            ],
            [False],
        ),
        # Multiple UUIDs requested
        # ------------------------
        # Base case, one reply (ours), primary and non-primary respectively
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [
                {
                    "current": {
                        "is_primary": True,
                        "uuid": "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                    }
                },
                {
                    "current": {
                        "is_primary": False,
                        "uuid": "ec641c22-0a5a-497e-acfb-a9be84dea48a",
                    }
                },
            ],
            [True, False],
        ),
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [
                {
                    "current": {
                        "is_primary": False,
                        "uuid": "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                    }
                },
                {
                    "current": {
                        "is_primary": True,
                        "uuid": "ec641c22-0a5a-497e-acfb-a9be84dea48a",
                    }
                },
            ],
            [False, True],
        ),
        # No results at all
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [],
            [False, False],
        ),
        # No current results
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [{"current": None}],
            [False, False],
        ),
        # Only one result
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [
                {
                    "current": {
                        "is_primary": True,
                        "uuid": "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                    }
                },
            ],
            [True, False],
        ),
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [
                {
                    "current": {
                        "is_primary": True,
                        "uuid": "ec641c22-0a5a-497e-acfb-a9be84dea48a",
                    }
                },
            ],
            [False, True],
        ),
        # Multiple non-current results
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [{"current": None}, {"current": None}],
            [False, False],
        ),
        # Multiple unrelated results
        (
            [
                "085bef5d-f435-4fe1-89d6-3d0f6b72d8e8",
                "ec641c22-0a5a-497e-acfb-a9be84dea48a",
            ],
            [
                {"current": {"is_primary": True, "uuid": uuid4()}},
                {"current": {"is_primary": True, "uuid": uuid4()}},
            ],
            [False, False],
        ),
    ],
)
async def test_is_primaries(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
    engagement_uuids: list[str],
    results: list[dict[str, Any]] | None,
    expected: list[bool],
) -> None:
    is_primary_engagements_route = graphql_mock.query("read_is_primary_engagements")
    is_primary_engagements_route.result = {"engagements": {"objects": results}}

    primary = await dataloader.moapi.is_primaries(list(map(UUID, engagement_uuids)))
    assert primary == expected

    assert is_primary_engagements_route.called


@pytest.mark.envvar({"LDAP_IT_SYSTEM": "ADUUID"})
async def test_get_ldap_it_system_uuid(
    graphql_mock: GraphQLMocker,
    dataloader: DataLoader,
) -> None:
    uuid = uuid4()
    route = graphql_mock.query("read_itsystem_uuid")
    route.result = {"itsystems": {"objects": [{"uuid": uuid}]}}

    assert await dataloader.moapi.get_ldap_it_system_uuid() == str(uuid)
    assert route.called

    route.reset()
    route.result = {"itsystems": {"objects": []}}
    assert await dataloader.moapi.get_ldap_it_system_uuid() is None
    assert route.called


async def test_find_mo_employee_dn(dataloader: MagicMock) -> None:
    employee_uuid = uuid4()

    dataloader.find_mo_employee_dn_by_itsystem = AsyncMock()
    dataloader.find_mo_employee_dn_by_itsystem.return_value = set()

    dataloader.find_mo_employee_dn_by_cpr_number = AsyncMock()
    dataloader.find_mo_employee_dn_by_cpr_number.return_value = set()

    with capture_logs() as cap_logs:
        result = await dataloader.find_mo_employee_dn(employee_uuid)
        assert result == set()
    log_events = [log["event"] for log in cap_logs]
    assert log_events == [
        "Attempting to find DNs",
        "Unable to find DNs for MO employee",
    ]

    dataloader.find_mo_employee_dn_by_itsystem.return_value = {"A", "B"}
    dataloader.find_mo_employee_dn_by_cpr_number.return_value = {"C", "D"}

    with capture_logs() as cap_logs:
        result = await dataloader.find_mo_employee_dn(employee_uuid)
        assert result == {"A", "B", "C", "D"}
    log_events = [log["event"] for log in cap_logs]
    assert log_events == ["Attempting to find DNs"]


async def test_make_mo_employee_dn_no_user(
    graphql_mock: GraphQLMocker, dataloader: MagicMock
) -> None:
    employee_uuid = uuid4()

    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": []}}

    with pytest.raises(NoObjectsReturnedException) as exc_info:
        await dataloader.make_mo_employee_dn(employee_uuid)
    assert f"Unable to lookup employee: {employee_uuid}" in str(exc_info.value)

    assert route.called


@pytest.mark.envvar({"LDAP_IT_SYSTEM": "ADUUID"})
async def test_make_mo_employee_dn_no_correlation(
    graphql_mock: GraphQLMocker, dataloader: MagicMock
) -> None:
    employee_uuid = uuid4()
    cpr_no = None

    route1 = graphql_mock.query("read_employees")
    route1.result = {
        "employees": {
            "objects": [
                {
                    "validities": [
                        {
                            "uuid": employee_uuid,
                            "cpr_no": cpr_no,
                            "givenname": "Hans",
                            "surname": "Andersen",
                            "nickname_givenname": None,
                            "nickname_surname": None,
                            "validity": {
                                "from": None,
                                "to": None,
                            },
                        }
                    ]
                }
            ]
        }
    }

    route2 = graphql_mock.query("read_itsystem_uuid")
    route2.result = {"itsystems": {"objects": []}}

    with pytest.raises(DNNotFound) as exc_info:
        await dataloader.make_mo_employee_dn(employee_uuid)
    assert "Unable to generate DN, no correlation key available" in str(exc_info.value)


async def test_make_mo_employee_dn_no_itsystem(
    dataloader: MagicMock,
    graphql_mock: GraphQLMocker,
) -> None:
    employee_uuid = uuid4()
    cpr_no = "0101700000"

    route1 = graphql_mock.query("read_employees")
    route1.result = {
        "employees": {
            "objects": [
                {
                    "validities": [
                        {
                            "uuid": employee_uuid,
                            "cpr_no": cpr_no,
                            "givenname": "Hans",
                            "surname": "Andersen",
                            "nickname_givenname": None,
                            "nickname_surname": None,
                            "validity": {
                                "from": None,
                                "to": None,
                            },
                        }
                    ]
                }
            ]
        }
    }

    route2 = graphql_mock.query("employee_refresh")
    route2.result = {"employee_refresh": {"objects": [employee_uuid]}}

    route3 = graphql_mock.query("read_itsystem_uuid")
    route3.result = {"itsystems": {"objects": []}}

    dn = "CN=foo"
    username_generator = AsyncMock()
    username_generator.generate_dn.return_value = dn

    dataloader.user_context["username_generator"] = username_generator

    amqp_exchange_name = "amqp_exchange_name"
    dataloader.amqpsystem.exchange_name = amqp_exchange_name

    with capture_logs() as cap_logs:
        result = await dataloader.make_mo_employee_dn(employee_uuid)
        assert result == dn
    log_events = [log["event"] for log in cap_logs]
    assert log_events == ["Generating DN for user"]


@pytest.mark.envvar({"LDAP_IT_SYSTEM": "ADUUID"})
async def test_make_mo_employee_dn_no_cpr(
    dataloader: MagicMock,
    graphql_mock: GraphQLMocker,
) -> None:
    employee_uuid = uuid4()
    cpr_no = None

    route1 = graphql_mock.query("read_employees")
    route1.result = {
        "employees": {
            "objects": [
                {
                    "validities": [
                        {
                            "uuid": employee_uuid,
                            "cpr_no": cpr_no,
                            "givenname": "Hans",
                            "surname": "Andersen",
                            "nickname_givenname": None,
                            "nickname_surname": None,
                            "validity": {
                                "from": None,
                                "to": None,
                            },
                        }
                    ]
                }
            ]
        }
    }

    route2 = graphql_mock.query("employee_refresh")
    route2.result = {"employee_refresh": {"objects": [employee_uuid]}}

    itsystem_uuid = uuid4()
    route3 = graphql_mock.query("read_itsystem_uuid")
    route3.result = {"itsystems": {"objects": [{"uuid": itsystem_uuid}]}}

    dn = "CN=foo"
    username_generator = AsyncMock()
    username_generator.generate_dn.return_value = dn

    dataloader.user_context["username_generator"] = username_generator

    ldap_uuid = uuid4()
    dataloader.ldapapi.get_ldap_unique_ldap_uuid = AsyncMock()
    dataloader.ldapapi.get_ldap_unique_ldap_uuid.return_value = ldap_uuid

    amqp_exchange_name = "amqp_exchange_name"
    dataloader.amqpsystem.exchange_name = amqp_exchange_name

    dataloader.create_ituser = AsyncMock()

    with capture_logs() as cap_logs:
        result = await dataloader.make_mo_employee_dn(employee_uuid)
        assert result == dn
    log_events = [log["event"] for log in cap_logs]
    assert log_events == [
        "Generating DN for user",
        "No ITUser found, creating one to correlate with DN",
        "LDAP UUID found for DN",
    ]

    dataloader.create_ituser.assert_called_once()


def test_extract_unique_objectGUIDs(dataloader: DataLoader) -> None:
    ad_it_user_1 = ITUser.from_simplified_fields(
        str(uuid4()),
        uuid4(),
        datetime.datetime.today().strftime("%Y-%m-%d"),
        person_uuid=uuid4(),
    )
    ad_it_user_2 = ITUser.from_simplified_fields(
        str(uuid4()),
        uuid4(),
        datetime.datetime.today().strftime("%Y-%m-%d"),
        person_uuid=uuid4(),
    )
    # from_simplified_fields() has bad type annotation
    assert isinstance(ad_it_user_1, ITUser)
    assert isinstance(ad_it_user_2, ITUser)

    objectGUIDs = dataloader.extract_unique_ldap_uuids([ad_it_user_1, ad_it_user_2])
    assert UUID(ad_it_user_1.user_key) in objectGUIDs
    assert UUID(ad_it_user_2.user_key) in objectGUIDs
    assert len(objectGUIDs) == 2

    ad_it_user_3 = ITUser.from_simplified_fields(
        "not_an_uuid",
        uuid4(),
        datetime.datetime.today().strftime("%Y-%m-%d"),
        person_uuid=uuid4(),
    )
    # from_simplified_fields() has bad type annotation
    assert isinstance(ad_it_user_3, ITUser)
    with pytest.raises(ExceptionGroup) as exc_info:
        dataloader.extract_unique_ldap_uuids([ad_it_user_1, ad_it_user_2, ad_it_user_3])
    exception = one(exc_info.value.exceptions)
    assert str(exception) == "Non UUID IT-user user-key: not_an_uuid"


@pytest.mark.parametrize(
    "ldap_dns,expected",
    [
        ([], set()),
        (["CN=foo"], {"CN=foo"}),
        (["CN=foo", "CN=foo"], {"CN=foo"}),
        (["CN=foo", "CN=bar"], {"CN=foo", "CN=bar"}),
        (["CN=foo", "CN=bar", "CN=bar"], {"CN=foo", "CN=bar"}),
        (["CN=foo", "CN=bar", "CN=baz"], {"CN=foo", "CN=bar", "CN=baz"}),
    ],
)
async def test_convert_ldap_uuids_to_dns(
    dataloader: DataLoader,
    ldap_dns: list[str],
    expected: set[str],
) -> None:
    dataloader.ldapapi.get_ldap_dn = AsyncMock()  # type: ignore
    dataloader.ldapapi.get_ldap_dn.side_effect = ldap_dns

    dns = await dataloader.ldapapi.convert_ldap_uuids_to_dns(
        {uuid4() for _ in ldap_dns}
    )
    assert dns == expected


async def test_convert_ldap_uuids_to_dns_exception(dataloader: DataLoader) -> None:
    dataloader.ldapapi.get_ldap_dn = AsyncMock()  # type: ignore
    dataloader.ldapapi.get_ldap_dn.side_effect = ["CN=foo", ValueError("BOOM")]

    with pytest.raises(ExceptionGroup) as exc_info:
        await dataloader.ldapapi.convert_ldap_uuids_to_dns({uuid4(), uuid4()})
    assert "Exceptions during UUID2DN translation" in str(exc_info.value)
    assert len(exc_info.value.exceptions) == 1

    dataloader.ldapapi.get_ldap_dn.side_effect = [
        ValueError("BANG"),
        ValueError("BOOM"),
    ]

    with pytest.raises(ExceptionGroup) as exc_info:
        await dataloader.ldapapi.convert_ldap_uuids_to_dns({uuid4(), uuid4()})
    assert "Exceptions during UUID2DN translation" in str(exc_info.value)
    assert len(exc_info.value.exceptions) == 2


async def test_get_ldap_dn(dataloader: DataLoader):
    with patch(
        "mo_ldap_import_export.ldapapi.single_object_search",
        return_value={"dn": "CN=foo"},
    ):
        assert await dataloader.ldapapi.get_ldap_dn(uuid4()) == "CN=foo"


async def test_get_ldap_unique_ldap_uuid(dataloader: DataLoader) -> None:
    uuid = uuid4()
    ldap_object = LdapObject(dn="foo", objectGUID=str(uuid))
    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object", return_value=ldap_object
    ):
        assert await dataloader.ldapapi.get_ldap_unique_ldap_uuid("") == uuid


async def test_get_ldap_unique_ldap_uuid_no_objectguid(dataloader: DataLoader) -> None:
    ldap_object = LdapObject(dn="foo", objectGUID=[])
    with (
        patch(
            "mo_ldap_import_export.ldapapi.get_ldap_object",
            return_value=ldap_object,
        ),
        pytest.raises(NoObjectsReturnedException),
    ):
        await dataloader.ldapapi.get_ldap_unique_ldap_uuid("")


async def test_load_ldap_attribute_values(dataloader: DataLoader):
    responses = [
        {"attributes": {"foo": 1}},
        {"attributes": {"foo": "2"}},
        {"attributes": {"foo": []}},
    ]
    with patch(
        "mo_ldap_import_export.routes.paged_search",
        return_value=responses,
    ):
        settings = dataloader.settings
        ldap_connection = dataloader.ldap_connection
        values = await load_ldap_attribute_values(settings, ldap_connection, "foo")
        assert "1" in values
        assert "2" in values
        assert "[]" in values
        assert len(values) == 3


async def test_create_mo_class(dataloader: DataLoader):
    uuid = uuid4()
    existing_class_uuid = uuid4()

    async def class_create(_) -> ClassCreateClassCreate:
        # Simulate creation time delay
        await asyncio.sleep(0.1)
        return ClassCreateClassCreate(uuid=uuid)

    dataloader.graphql_client.class_create.side_effect = class_create  # type: ignore

    class_not_found_response = ReadClassUuidClasses(objects=[])
    class_exists_response = ReadClassUuidClasses(
        objects=[ReadClassUuidClassesObjects(uuid=existing_class_uuid)]
    )

    # Case1: The class does not exist yet
    dataloader.graphql_client.read_class_uuid.return_value = class_not_found_response  # type: ignore
    assert await dataloader.create_mo_class("", "", uuid4()) == uuid

    # Case2: The class already exists
    dataloader.graphql_client.read_class_uuid.return_value = class_exists_response  # type: ignore
    assert await dataloader.create_mo_class("", "", uuid4()) == existing_class_uuid

    # Case3: We call the function twice and the first one needs to wait for the second
    dataloader.graphql_client.read_class_uuid.return_value = class_not_found_response  # type: ignore

    # Because of the lock, only one instance can run at the time.
    t1 = time.time()
    await asyncio.gather(
        dataloader.create_mo_class("n", "user_key", uuid4()),
        dataloader.create_mo_class("n", "user_key", uuid4()),
    )
    t2 = time.time()
    assert (t2 - t1) > 0.2  # each task takes 0.1 second


async def test_create_mo_job_function(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    route1 = graphql_mock.query("read_class_uuid_by_facet_and_class_user_key")
    route1.result = {"classes": {"objects": []}}

    uuid1 = uuid4()
    route2 = graphql_mock.query("read_facet_uuid")
    route2.result = {"facets": {"objects": [{"uuid": uuid1}]}}

    uuid2 = uuid4()

    dataloader.create_mo_class = AsyncMock()  # type: ignore
    dataloader.create_mo_class.return_value = uuid2

    assert await get_or_create_job_function_uuid(dataloader, "foo") == str(uuid2)
    assert await get_or_create_engagement_type_uuid(dataloader, "bar") == str(uuid2)

    kwargs = dataloader.create_mo_class.call_args_list[0].kwargs
    assert kwargs == {"name": "foo", "user_key": "foo", "facet_uuid": uuid1}

    kwargs = dataloader.create_mo_class.call_args_list[1].kwargs
    assert kwargs == {"name": "bar", "user_key": "bar", "facet_uuid": uuid1}


async def test_load_mo_facet_uuid(dataloader: DataLoader, graphql_mock: GraphQLMocker):
    uuid = uuid4()

    route = graphql_mock.query("read_facet_uuid")
    route.result = {"facets": {"objects": [{"uuid": uuid}]}}
    assert await dataloader.moapi.load_mo_facet_uuid("") == uuid
    assert route.called


async def test_load_mo_facet_uuid_multiple_facets(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
):
    route = graphql_mock.query("read_facet_uuid")
    route.result = {
        "facets": {
            "objects": [
                {"uuid": uuid4()},
                {"uuid": uuid4()},
            ]
        }
    }
    with pytest.raises(MultipleObjectsReturnedException):
        await dataloader.moapi.load_mo_facet_uuid("")
    assert route.called


async def test_load_mo_facet_uuid_no_result(dataloader: DataLoader):
    dataloader.graphql_client.read_facet_uuid.return_value = parse_obj_as(  # type: ignore
        ReadFacetUuidFacets, {"objects": []}
    )
    result = await dataloader.moapi.load_mo_facet_uuid("")
    assert result is None


async def test_add_ldap_object(settings: Settings, ldap_connection: MagicMock) -> None:
    ldapapi = LDAPAPI(settings, ldap_connection)

    ldap_connection.get_response.return_value = [], {"type": "test"}

    await ldapapi.add_ldap_object("CN=foo", attributes={"foo": 2})
    ldap_connection.add.assert_called_once()  # type: ignore

    ldapapi.settings = MagicMock()  # type: ignore
    ldapapi.settings.add_objects_to_ldap = False
    ldapapi.settings.ldap_read_only = False

    with pytest.raises(ReadOnlyException) as exc:
        await ldapapi.add_ldap_object("CN=foo")
    assert "Adding LDAP objects is disabled" in str(exc.value)

    ldapapi.ldap_connection.reset_mock()  # type: ignore
    ldapapi.settings.add_objects_to_ldap = True
    ldapapi.ou_in_ous_to_write_to = MagicMock()  # type: ignore
    ldapapi.ou_in_ous_to_write_to.return_value = False

    with pytest.raises(ReadOnlyException) as exc:
        await ldapapi.add_ldap_object("CN=foo")
    assert "Not allowed to write to the specified OU" in str(exc.value)

    ldapapi.settings.ldap_read_only = True
    with pytest.raises(ReadOnlyException) as exc:
        await ldapapi.add_ldap_object("CN=foo")
    assert "LDAP connection is read-only" in str(exc.value)


async def test_load_mo_employee_engagement_dicts(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    engagement1 = jsonable_encoder(
        {
            "uuid": uuid4(),
            "user_key": "foo",
            "org_unit_uuid": uuid4(),
            "job_function_uuid": uuid4(),
            "engagement_type_uuid": uuid4(),
            "primary_uuid": None,
        }
    )
    engagement2 = jsonable_encoder(
        {
            "uuid": uuid4(),
            "user_key": "foo",
            "org_unit_uuid": uuid4(),
            "job_function_uuid": uuid4(),
            "engagement_type_uuid": uuid4(),
            "primary_uuid": None,
        }
    )

    route = graphql_mock.query("read_engagements_by_engagements_filter")
    route.result = {
        "engagements": {"objects": [{"current": engagement1}, {"current": engagement2}]}
    }

    result = await dataloader.moapi.load_mo_employee_engagement_dicts(uuid4(), "foo")

    assert engagement1 in result
    assert engagement2 in result
    assert route.called

    route.reset()
    route.result = {"engagements": {"objects": []}}
    result = await dataloader.moapi.load_mo_employee_engagement_dicts(uuid4(), "foo")

    assert isinstance(result, list)
    assert len(result) == 0
    assert route.called


def test_ou_in_ous_to_write_to(dataloader: DataLoader):
    settings_mock = MagicMock()
    settings_mock.ldap_ous_to_write_to = ["OU=foo", "OU=mucki,OU=bar"]
    dataloader.ldapapi.settings = settings_mock

    assert dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,OU=foo,DC=k") is True
    assert dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,OU=bar,DC=k") is False
    assert (
        dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,OU=mucki,OU=bar,DC=k")
        is True
    )
    assert dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,DC=k") is False

    settings_mock.ldap_ous_to_write_to = [""]
    dataloader.ldapapi.settings = settings_mock

    assert dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,OU=foo,DC=k") is True
    assert dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,OU=bar,DC=k") is True
    assert (
        dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,OU=mucki,OU=bar,DC=k")
        is True
    )
    assert dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,DC=k") is True


async def test_load_all_current_it_users_no_paged(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
) -> None:
    itsystem1_uuid = uuid4()

    route = graphql_mock.query("read_all_itusers")
    route.result = {
        "itusers": {
            "objects": [
                {
                    "validities": [
                        {
                            "itsystem_uuid": str(itsystem1_uuid),
                            "employee_uuid": str(uuid4()),
                            "user_key": "foo",
                            "uuid": str(uuid4()),
                        }
                    ]
                }
            ],
            "page_info": {"next_cursor": None},
        }
    }
    results = await load_all_current_it_users(dataloader.graphql_client, itsystem1_uuid)
    result = one(results)
    assert result["itsystem_uuid"] == str(itsystem1_uuid)
    assert result["user_key"] == "foo"


async def test_load_all_current_it_users_paged(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
) -> None:
    itsystem1_uuid = uuid4()

    query_results = [
        {
            "itusers": {
                "objects": [
                    {
                        "validities": [
                            {
                                "itsystem_uuid": str(itsystem1_uuid),
                                "employee_uuid": str(uuid4()),
                                "user_key": "foo",
                                "uuid": str(uuid4()),
                            }
                        ]
                    }
                ],
                "page_info": {"next_cursor": "VGhlIGNha2UgaXMgYSBsaWUK"},  # Fake cursor
            }
        },
        {
            "itusers": {
                "objects": [
                    {
                        "validities": [
                            {
                                "itsystem_uuid": str(itsystem1_uuid),
                                "employee_uuid": str(uuid4()),
                                "user_key": "bar",
                                "uuid": str(uuid4()),
                            }
                        ]
                    }
                ],
                "page_info": {"next_cursor": None},
            }
        },
    ]

    def pager(_: Any, route: Any) -> Response:
        # Gets called once per GraphQL httpx request
        # Each call increments route.call_count by one
        result = query_results[route.call_count]
        return Response(200, json={"data": jsonable_encoder(result)})

    route = graphql_mock.query("read_all_itusers")
    route.mock(side_effect=pager)
    results = await load_all_current_it_users(dataloader.graphql_client, itsystem1_uuid)
    assert len(results) == 2

    first, second = results
    assert first["itsystem_uuid"] == str(itsystem1_uuid)
    assert first["user_key"] == "foo"

    assert second["itsystem_uuid"] == str(itsystem1_uuid)
    assert second["user_key"] == "bar"


uuid_obj1 = uuid4()
uuid_obj2 = uuid4()
uuid_obj3 = uuid4()


@freeze_time("2022-08-10")
@pytest.mark.parametrize(
    "validities,expected",
    [
        # One of the objects is valid today - return it
        (
            [
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": "2022-08-02T00:00:00+02:00",
                        "to": "2022-08-15T00:00:00+02:00",
                    },
                    "uuid": uuid_obj2,
                },
                {
                    "validity": {
                        "from": "2022-08-15T00:00:00+02:00",
                        "to": None,
                    },
                    "uuid": uuid_obj3,
                },
            ],
            uuid_obj2,
        ),
        # One of the objects is valid all the time - return it
        (
            [
                # NOTE: This combination should never exist, but we wanna test the codepath
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": None,
                        "to": None,
                    },
                    "uuid": uuid_obj3,
                },
            ],
            uuid_obj3,
        ),
        # No object is valid today - return the latest
        (
            [
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": "2022-08-15T00:00:00+02:00",
                        "to": None,
                    },
                    "uuid": uuid_obj3,
                },
            ],
            uuid_obj3,
        ),
        # No valid current object - return the latest
        (
            [
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": "2022-08-15T00:00:00+02:00",
                        "to": "2022-08-20T00:00:00+02:00",
                    },
                    "uuid": uuid_obj2,
                },
            ],
            uuid_obj2,
        ),
        # One of the objects is valid today (without to-date) - return it
        (
            [
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": "2022-08-02T00:00:00+02:00",
                        "to": None,
                    },
                    "uuid": uuid_obj2,
                },
            ],
            uuid_obj2,
        ),
        # One of the objects is valid today (without from-date)- return it
        (
            [
                {
                    "validity": {
                        "from": None,
                        "to": "2022-08-15T00:00:00+02:00",
                    },
                    "uuid": uuid_obj2,
                },
                {
                    "validity": {
                        "from": "2022-08-15T00:00:00+02:00",
                        "to": None,
                    },
                    "uuid": uuid_obj3,
                },
            ],
            uuid_obj2,
        ),
    ],
)
def test_extract_latest_object(
    validities: list[dict[str, Any]], expected: UUID
) -> None:
    class Validity(BaseModel):
        from_: datetime.datetime | None = Field(alias="from")
        to: datetime.datetime | None

    class ValidityUUID(BaseModel):
        uuid: UUID
        validity: Validity

    obj_validities = parse_obj_as(list[ValidityUUID], validities)
    result = extract_current_or_latest_validity(obj_validities)
    assert result is not None
    assert result.uuid == expected


def test_extract_latest_object_empty() -> None:
    result = extract_current_or_latest_validity([])
    assert result is None


async def test_load_mo_root_org_uuid(graphql_mock: GraphQLMocker) -> None:
    graphql_client = GraphQLClient("http://example.com/graphql")
    root_org_uuid = uuid4()

    route = graphql_mock.query("read_root_org_uuid")
    route.result = {"org": {"uuid": root_org_uuid}}

    assert await load_mo_root_org_uuid(graphql_client) == root_org_uuid


async def test_create_or_edit_mo_objects(dataloader: DataLoader) -> None:
    # One object is created and another is edited.
    create = MagicMock()
    del create.terminate_

    edit = MagicMock()
    del edit.terminate_

    terminate = MagicMock()

    objs = [(create, Verb.CREATE), (edit, Verb.EDIT), (terminate, Verb.TERMINATE)]

    dataloader.create = AsyncMock()  # type: ignore
    dataloader.edit = AsyncMock()  # type: ignore
    dataloader.terminate = AsyncMock()  # type: ignore

    await dataloader.create_or_edit_mo_objects(objs)  # type: ignore
    dataloader.create.assert_called_once_with([create])
    dataloader.edit.assert_called_once_with([edit])
    dataloader.terminate.assert_called_once_with([terminate])


@pytest.mark.parametrize(
    "cpr_number,dns,expected",
    [
        # No CPR number -> no DNs
        (None, None, set()),
        # CPR number, but no accounts -> no DNs
        ("0101700000", [], set()),
        # CPR number and one account -> one DN
        ("0101700000", ["CN=foo"], {"CN=foo"}),
        # CPR number and two accounts -> two DN
        ("0101700000", ["CN=foo", "CN=bar"], {"CN=foo", "CN=bar"}),
    ],
)
async def test_find_mo_employee_dn_by_cpr_number(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
    cpr_number: str | None,
    dns: list[str] | None,
    expected: set[str] | str,
) -> None:
    employee_uuid = uuid4()
    employee = {
        "uuid": employee_uuid,
        "cpr_no": cpr_number,
        "givenname": "first_name",
        "surname": "last_name",
        "nickname_givenname": None,
        "nickname_surname": None,
        "validity": {"to": None},
    }
    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": [{"validities": [employee]}]}}

    dataloader.ldapapi.cpr2dns = AsyncMock()  # type: ignore
    dataloader.ldapapi.cpr2dns.return_value = {dn for dn in (dns or [])}

    result = await dataloader.find_mo_employee_dn_by_cpr_number(employee_uuid)
    assert result == expected

    if dns is not None:
        dataloader.ldapapi.cpr2dns.assert_called_once_with(cpr_number)


@pytest.mark.envvar({"LDAP_IT_SYSTEM": "ADUUID"})
async def test_find_mo_employee_dn_by_itsystem_no_itsystem(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
) -> None:
    employee_uuid = uuid4()

    route = graphql_mock.query("read_itsystem_uuid")
    route.result = {"itsystems": {"objects": []}}

    result = await dataloader.find_mo_employee_dn_by_itsystem(employee_uuid)
    assert result == set()


@pytest.mark.envvar({"LDAP_IT_SYSTEM": "ADUUID"})
async def test_find_mo_employee_dn_by_itsystem_no_match(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
) -> None:
    employee_uuid = uuid4()
    itsystem_uuid = uuid4()

    route1 = graphql_mock.query("read_itsystem_uuid")
    route1.result = {"itsystems": {"objects": [{"uuid": itsystem_uuid}]}}

    route2 = graphql_mock.query("read_ituser_by_employee_and_itsystem_uuid")
    route2.result = {"itusers": {"objects": []}}

    result = await dataloader.find_mo_employee_dn_by_itsystem(employee_uuid)
    assert result == set()


@pytest.mark.envvar({"LDAP_IT_SYSTEM": "ADUUID"})
async def test_find_mo_employee_dn_by_itsystem(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
) -> None:
    employee_uuid = uuid4()
    itsystem_uuid = uuid4()
    ituser_uuid = uuid4()

    route1 = graphql_mock.query("read_itsystem_uuid")
    route1.result = {"itsystems": {"objects": [{"uuid": itsystem_uuid}]}}

    route2 = graphql_mock.query("read_ituser_by_employee_and_itsystem_uuid")
    route2.result = {"itusers": {"objects": [{"uuid": ituser_uuid}]}}

    route3 = graphql_mock.query("read_itusers")
    route3.result = {
        "itusers": {
            "objects": [
                {
                    "validities": [
                        {
                            "user_key": ituser_uuid,
                            "validity": {"from": "1970-01-01T00:00:00Z"},
                            "employee_uuid": employee_uuid,
                            "itsystem_uuid": itsystem_uuid,
                            "engagement_uuid": None,
                        }
                    ]
                }
            ]
        }
    }

    dn = "CN=foo"
    dataloader.ldapapi.get_ldap_dn = AsyncMock()  # type: ignore
    dataloader.ldapapi.get_ldap_dn.return_value = dn

    result = await dataloader.find_mo_employee_dn_by_itsystem(employee_uuid)
    assert result == {dn}

    dataloader.ldapapi.get_ldap_dn.assert_called_once_with(ituser_uuid)
