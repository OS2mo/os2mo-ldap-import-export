# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
# pylint: disable=redefined-outer-name
# pylint: disable=unused-argument
# pylint: disable=protected-access
import asyncio
import datetime
import json
import time
from collections.abc import Collection
from collections.abc import Iterator
from typing import Any
from typing import cast
from unittest.mock import AsyncMock
from unittest.mock import MagicMock
from unittest.mock import patch
from uuid import UUID
from uuid import uuid4

import pytest
from fastapi.encoders import jsonable_encoder
from fastramqpi.ramqp.utils import RequeueMessage
from httpx import Response
from ldap3.core.exceptions import LDAPInvalidValueError
from more_itertools import one
from pydantic import BaseModel
from pydantic import Field
from pydantic import parse_obj_as
from structlog.testing import capture_logs

from mo_ldap_import_export.autogenerated_graphql_client.class_create import (
    ClassCreateClassCreate,
)
from mo_ldap_import_export.autogenerated_graphql_client.client import GraphQLClient
from mo_ldap_import_export.autogenerated_graphql_client.read_class_uuid import (
    ReadClassUuidClasses,
)
from mo_ldap_import_export.autogenerated_graphql_client.read_class_uuid import (
    ReadClassUuidClassesObjects,
)
from mo_ldap_import_export.autogenerated_graphql_client.read_employee_uuid_by_cpr_number import (
    ReadEmployeeUuidByCprNumberEmployees,
)
from mo_ldap_import_export.autogenerated_graphql_client.read_employee_uuid_by_ituser_user_key import (
    ReadEmployeeUuidByItuserUserKeyItusers,
)
from mo_ldap_import_export.autogenerated_graphql_client.read_facet_uuid import (
    ReadFacetUuidFacets,
)
from mo_ldap_import_export.config import Settings
from mo_ldap_import_export.dataloaders import DN
from mo_ldap_import_export.dataloaders import DataLoader
from mo_ldap_import_export.environments.main import get_or_create_job_function_uuid
from mo_ldap_import_export.exceptions import MultipleObjectsReturnedException
from mo_ldap_import_export.exceptions import NoObjectsReturnedException
from mo_ldap_import_export.exceptions import ReadOnlyException
from mo_ldap_import_export.ldap_classes import LdapObject
from mo_ldap_import_export.ldapapi import LDAPAPI
from mo_ldap_import_export.moapi import MOAPI
from mo_ldap_import_export.moapi import Verb
from mo_ldap_import_export.moapi import extract_current_or_latest_validity
from mo_ldap_import_export.models import Address
from mo_ldap_import_export.models import Employee
from mo_ldap_import_export.models import ITUser
from mo_ldap_import_export.models import Termination
from mo_ldap_import_export.routes import load_all_current_it_users
from mo_ldap_import_export.routes import load_ldap_attribute_values
from mo_ldap_import_export.types import LDAPUUID
from tests.graphql_mocker import GraphQLMocker


@pytest.fixture()
def ldap_attributes() -> dict:
    return {
        "department": None,
        "name": "John",
        "employeeID": "0101011234",
        "postalAddress": "foo",
    }


@pytest.fixture
def cpr_field() -> str:
    return "employeeID"


@pytest.fixture
def ldap_connection() -> Iterator[MagicMock]:
    """Fixture to construct a mock ldap_connection.

    Yields:
        A mock for ldap_connection.
    """
    ldap_connection = MagicMock()
    yield ldap_connection


@pytest.fixture
def legacy_graphql_session() -> Iterator[AsyncMock]:
    yield AsyncMock()


@pytest.fixture
def graphql_client() -> Iterator[AsyncMock]:
    yield AsyncMock()


@pytest.fixture
def settings(minimal_mapping: dict[str, Any], monkeypatch: pytest.MonkeyPatch):
    monkeypatch.setenv("CONVERSION_MAPPING", json.dumps(minimal_mapping))
    monkeypatch.setenv("CLIENT_ID", "foo")
    monkeypatch.setenv("CLIENT_SECRET", "bar")
    monkeypatch.setenv("LDAP_CONTROLLERS", '[{"host": "0.0.0.0"}]')
    monkeypatch.setenv("LDAP_DOMAIN", "LDAP")
    monkeypatch.setenv("LDAP_USER", "foo")
    monkeypatch.setenv("LDAP_PASSWORD", "bar")
    monkeypatch.setenv("LDAP_SEARCH_BASE", "DC=ad,DC=addev")
    monkeypatch.setenv("LDAP_OBJECT_CLASS", "inetOrgPerson")
    monkeypatch.setenv("LDAP_CPR_ATTRIBUTE", "employeeID")
    monkeypatch.setenv("DEFAULT_ORG_UNIT_LEVEL", "foo")
    monkeypatch.setenv("DEFAULT_ORG_UNIT_TYPE", "foo")
    monkeypatch.setenv("LDAP_OUS_TO_WRITE_TO", '[""]')
    monkeypatch.setenv("FASTRAMQPI__AMQP__URL", "amqp://guest:guest@msg_broker:5672/")
    monkeypatch.setenv("INTERNAL_AMQP__URL", "amqp://guest:guest@msg_broker:5672/")

    return Settings()


@pytest.fixture
def converter() -> MagicMock:
    converter_mock = MagicMock()
    converter_mock.find_ldap_object_class.return_value = "user"
    return converter_mock


@pytest.fixture
def username_generator() -> MagicMock:
    return AsyncMock()


@pytest.fixture
def sync_tool() -> AsyncMock:
    sync_tool = AsyncMock()
    return sync_tool


@pytest.fixture
def dataloader(
    ldap_connection: MagicMock,
    graphql_client: AsyncMock,
    settings: Settings,
    username_generator: MagicMock,
) -> DataLoader:
    """Fixture to construct a dataloaders object using fixture mocks.

    Yields:
        Dataloaders with mocked clients.
    """
    return DataLoader(
        settings,
        MOAPI(settings, graphql_client),
        LDAPAPI(settings, ldap_connection),
        username_generator,
    )


@pytest.fixture
def graphql_mock(dataloader, respx_mock) -> Iterator[GraphQLMocker]:
    graphql_client = GraphQLClient("http://example.com/graphql")
    dataloader.moapi.graphql_client = graphql_client

    yield GraphQLMocker(respx_mock)


def mock_ldap_response(ldap_attributes: dict, dn: DN) -> dict[str, Collection[str]]:
    expected_attributes = ldap_attributes.keys()
    inner_dict = ldap_attributes

    for attribute in expected_attributes:
        if attribute not in inner_dict:
            inner_dict[attribute] = None

    response = {"dn": dn, "type": "searchResEntry", "attributes": inner_dict}

    return response


async def test_upload_ldap_object_invalid_value(
    ldap_connection: MagicMock,
    dataloader: DataLoader,
) -> None:
    dataloader.ldapapi.ldap_connection.get_response.return_value = (
        [],
        {"type": "test", "description": "compareFalse"},
    )

    dn = "CN=Nick Janssen,OU=Users,OU=Magenta,DC=ad,DC=addev"

    ldap_connection.modify.side_effect = LDAPInvalidValueError("Invalid value")

    with pytest.raises(LDAPInvalidValueError) as exc_info:
        await dataloader.ldapapi.modify_ldap_object(dn, {"a": ["b"]})
    assert "Invalid value" in str(exc_info.value)


@pytest.mark.usefixtures("minimal_valid_environmental_variables")
async def test_modify_ldap_object_read_only(
    dataloader: DataLoader,
    monkeypatch: pytest.MonkeyPatch,
) -> None:
    monkeypatch.setenv("LDAP_READ_ONLY", "True")
    dataloader.ldapapi.settings = Settings()

    with pytest.raises(ReadOnlyException) as exc_info:
        await dataloader.ldapapi.modify_ldap_object("CN=Foo", {})
    assert "LDAP connection is read-only" in str(exc_info.value)


@pytest.mark.usefixtures("minimal_valid_environmental_variables")
async def test_modify_ldap_object_invalid_ou(
    dataloader: DataLoader,
    monkeypatch: pytest.MonkeyPatch,
) -> None:
    monkeypatch.setenv("LDAP_OUS_TO_WRITE_TO", '["OU=non-existent"]')
    settings = Settings()

    dataloader.settings = settings
    dataloader.ldapapi = LDAPAPI(settings, dataloader.ldapapi.ldap_connection)

    dn = "UID=abk,OU=os2mo,O=magenta,DC=magenta,DC=dk"
    with capture_logs() as cap_logs:
        await dataloader.ldapapi.modify_ldap_object(dn, {})
    messages = [w["event"] for w in cap_logs]
    assert messages == [
        "OU not in OUs to write",
        "Not allowed to write to the specified OU",
    ]


async def test_load_mo_employee(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    cpr_number = "1407711900"
    uuid = uuid4()

    employee = {
        "uuid": uuid,
        "user_key": "user_key",
        "cpr_number": cpr_number,
        "given_name": "first_name",
        "surname": "last_name",
        "nickname_given_name": "",
        "nickname_surname": "",
        "validity": {"to": None},
    }

    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": [{"validities": [employee]}]}}

    employee.pop("validity")
    expected_result = Employee(**employee)

    output = await dataloader.moapi.load_mo_employee(uuid)
    assert output == expected_result
    assert route.called


async def test_load_mo_employee_no_objects(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    uuid = uuid4()

    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": []}}

    result = await dataloader.moapi.load_mo_employee(uuid)
    assert result is None
    assert route.called


async def test_load_mo_employee_no_validities(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    uuid = uuid4()

    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": [{"validities": []}]}}

    result = await dataloader.moapi.load_mo_employee(uuid)
    assert result is None
    assert route.called


def mock_read_employee_uuid_by_cpr_number(
    dataloader: DataLoader, values: list[UUID]
) -> None:
    dataloader.moapi.graphql_client.read_employee_uuid_by_cpr_number.return_value = (  # type: ignore
        parse_obj_as(
            ReadEmployeeUuidByCprNumberEmployees,
            {"objects": [{"uuid": uuid} for uuid in values]},
        )
    )


def mock_read_employee_uuid_by_ituser(
    dataloader: DataLoader, values: list[UUID]
) -> None:
    dataloader.moapi.graphql_client.read_employee_uuid_by_ituser_user_key.return_value = (  # type: ignore
        parse_obj_as(
            ReadEmployeeUuidByItuserUserKeyItusers,
            {"objects": [{"current": {"employee_uuid": uuid}} for uuid in values]},
        )
    )


async def test_find_mo_employee_uuid_by_cpr_number(dataloader: DataLoader):
    uuid = uuid4()

    ldap_object = LdapObject(
        dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
    )

    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object", return_value=ldap_object
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [uuid])
        mock_read_employee_uuid_by_ituser(dataloader, [])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output == uuid


async def test_find_mo_employee_uuid_by_ituser(dataloader: DataLoader):
    uuid = uuid4()

    ldap_object = LdapObject(dn="CN=foo", employeeID="Ja", objectGUID=str(uuid4()))
    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object", return_value=ldap_object
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [])
        mock_read_employee_uuid_by_ituser(dataloader, [uuid])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output == uuid


async def test_find_mo_employee_uuid_fallback_ituser(
    dataloader: DataLoader, monkeypatch: pytest.MonkeyPatch
) -> None:
    monkeypatch.delenv("LDAP_CPR_ATTRIBUTE")
    monkeypatch.setenv("LDAP_IT_SYSTEM", "ADUUID")
    dataloader.settings = Settings()
    dataloader.ldapapi.settings = Settings()

    uuid1 = uuid4()
    uuid2 = uuid4()

    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object",
        return_value=LdapObject(
            dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
        ),
    ):
        # There is a CPR match, but it is not configured, so we get the ITUser match
        mock_read_employee_uuid_by_cpr_number(dataloader, [uuid1])
        mock_read_employee_uuid_by_ituser(dataloader, [uuid2])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output == uuid2


async def test_find_mo_employee_uuid_not_found(dataloader: DataLoader):
    ldap_object = LdapObject(
        dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
    )
    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object", return_value=ldap_object
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [])
        mock_read_employee_uuid_by_ituser(dataloader, [])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output is None


async def test_find_mo_employee_uuid_cpr_number_multiple_matches(
    dataloader: DataLoader,
):
    ldap_object = LdapObject(
        dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
    )
    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object", return_value=ldap_object
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [uuid4(), uuid4()])
        mock_read_employee_uuid_by_ituser(dataloader, [])
        with pytest.raises(MultipleObjectsReturnedException):
            await dataloader.find_mo_employee_uuid("CN=foo")


async def test_find_mo_employee_uuid_ituser_multiple_matches(dataloader: DataLoader):
    ldap_object = LdapObject(
        dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
    )
    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object", return_value=ldap_object
    ):
        mock_read_employee_uuid_by_cpr_number(dataloader, [])
        mock_read_employee_uuid_by_ituser(dataloader, [uuid4(), uuid4()])
        with pytest.raises(MultipleObjectsReturnedException):
            await dataloader.find_mo_employee_uuid("CN=foo")


async def test_find_mo_employee_uuid_multiple_matches(dataloader: DataLoader):
    uuid1 = uuid4()
    uuid2 = uuid4()

    ldap_object = LdapObject(
        dn="CN=foo", employeeID="0101011221", objectGUID=str(uuid4())
    )
    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object", return_value=ldap_object
    ):
        # We never actually check ituser, due to early return
        mock_read_employee_uuid_by_cpr_number(dataloader, [uuid1])
        mock_read_employee_uuid_by_ituser(dataloader, [uuid2])
        output = await dataloader.find_mo_employee_uuid("CN=foo")
        assert output == uuid1


async def test_load_mo_employee_not_found(
    dataloader: DataLoader, legacy_graphql_session: AsyncMock
):
    legacy_graphql_session.execute.return_value = {"employees": {"objects": []}}

    uuid = uuid4()

    result = await dataloader.moapi.load_mo_employee(uuid)
    assert result is None


async def test_load_mo_engagement(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    route = graphql_mock.query("read_engagements")
    route.result = {
        "engagements": {
            "objects": [
                {
                    "validities": [
                        {
                            "user_key": "foo",
                            "validity": {"from": "2021-01-01T00:00:00", "to": None},
                            "extension_1": "extra info",
                            "extension_2": "more extra info",
                            "extension_3": None,
                            "extension_4": None,
                            "extension_5": None,
                            "extension_6": None,
                            "extension_7": None,
                            "extension_8": None,
                            "extension_9": None,
                            "extension_10": None,
                            "leave_uuid": uuid4(),
                            "primary_uuid": uuid4(),
                            "job_function_uuid": uuid4(),
                            "org_unit_uuid": uuid4(),
                            "engagement_type_uuid": uuid4(),
                            "employee_uuid": uuid4(),
                        }
                    ]
                }
            ]
        }
    }

    output = await dataloader.moapi.load_mo_engagement(uuid4())
    assert output is not None
    assert output.user_key == "foo"
    assert output.validity.start.date() == datetime.date(2021, 1, 1)
    assert output.extension_1 == "extra info"
    assert output.extension_2 == "more extra info"

    assert route.called


@pytest.mark.parametrize(
    "objects",
    [
        # No objects returned
        [],
        # Object returned, but no validities
        [{"validities": []}],
    ],
)
async def test_load_mo_engagement_not_found(
    dataloader: DataLoader, graphql_mock: GraphQLMocker, objects: list[dict]
) -> None:
    route = graphql_mock.query("read_engagements")
    route.result = {"engagements": {"objects": objects}}

    result = await dataloader.moapi.load_mo_engagement(uuid4())
    assert result is None

    assert route.called


@pytest.mark.envvar({"LDAP_IT_SYSTEM": "ADUUID"})
async def test_get_ldap_it_system_uuid(
    graphql_mock: GraphQLMocker,
    dataloader: DataLoader,
) -> None:
    uuid = uuid4()
    route = graphql_mock.query("read_itsystem_uuid")
    route.result = {"itsystems": {"objects": [{"uuid": uuid}]}}

    assert await dataloader.moapi.get_ldap_it_system_uuid() == str(uuid)
    assert route.called

    route.reset()
    route.result = {"itsystems": {"objects": []}}
    assert await dataloader.moapi.get_ldap_it_system_uuid() is None
    assert route.called


async def test_find_mo_employee_dn(dataloader: MagicMock) -> None:
    employee_uuid = uuid4()

    dataloader.find_mo_employee_dn_by_itsystem = AsyncMock()
    dataloader.find_mo_employee_dn_by_itsystem.return_value = set()

    dataloader.find_mo_employee_dn_by_cpr_number = AsyncMock()
    dataloader.find_mo_employee_dn_by_cpr_number.return_value = set()

    with capture_logs() as cap_logs:
        result = await dataloader.find_mo_employee_dn(employee_uuid)
        assert result == set()
    log_events = [log["event"] for log in cap_logs]
    assert log_events == [
        "Attempting to find DNs",
        "Unable to find DNs for MO employee",
    ]

    dataloader.find_mo_employee_dn_by_itsystem.return_value = {"A", "B"}
    dataloader.find_mo_employee_dn_by_cpr_number.return_value = {"C", "D"}

    with capture_logs() as cap_logs:
        result = await dataloader.find_mo_employee_dn(employee_uuid)
        assert result == {"A", "B", "C", "D"}
    log_events = [log["event"] for log in cap_logs]
    assert log_events == ["Attempting to find DNs", "Found DNs for MO employee"]


async def test_make_mo_employee_dn_no_user(
    graphql_mock: GraphQLMocker, dataloader: MagicMock
) -> None:
    employee_uuid = uuid4()

    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": []}}

    with pytest.raises(NoObjectsReturnedException) as exc_info:
        await dataloader.make_mo_employee_dn(employee_uuid)
    assert f"Unable to lookup employee: {employee_uuid}" in str(exc_info.value)

    assert route.called


@pytest.mark.envvar({"LDAP_IT_SYSTEM": "ADUUID"})
async def test_make_mo_employee_dn_no_correlation(
    graphql_mock: GraphQLMocker, dataloader: MagicMock
) -> None:
    employee_uuid = uuid4()
    cpr_number = None

    route1 = graphql_mock.query("read_employees")
    route1.result = {
        "employees": {
            "objects": [
                {
                    "validities": [
                        {
                            "uuid": employee_uuid,
                            "user_key": "ha",
                            "cpr_number": cpr_number,
                            "given_name": "Hans",
                            "surname": "Andersen",
                            "nickname_given_name": "",
                            "nickname_surname": "",
                            "validity": {
                                "from": None,
                                "to": None,
                            },
                        }
                    ]
                }
            ]
        }
    }

    route2 = graphql_mock.query("read_itsystem_uuid")
    route2.result = {"itsystems": {"objects": []}}

    with pytest.raises(RequeueMessage) as exc_info:
        await dataloader.make_mo_employee_dn(employee_uuid)
    assert "Unable to generate DN, no correlation key available" in str(exc_info.value)


async def test_make_mo_employee_dn_no_itsystem(
    dataloader: MagicMock,
    graphql_mock: GraphQLMocker,
) -> None:
    employee_uuid = uuid4()
    cpr_number = "0101700000"

    route1 = graphql_mock.query("read_employees")
    route1.result = {
        "employees": {
            "objects": [
                {
                    "validities": [
                        {
                            "uuid": employee_uuid,
                            "user_key": "ha",
                            "cpr_number": cpr_number,
                            "given_name": "Hans",
                            "surname": "Andersen",
                            "nickname_given_name": "",
                            "nickname_surname": "",
                            "validity": {
                                "from": None,
                                "to": None,
                            },
                        }
                    ]
                }
            ]
        }
    }

    route2 = graphql_mock.query("employee_refresh")
    route2.result = {"employee_refresh": {"objects": [employee_uuid]}}

    route3 = graphql_mock.query("read_itsystem_uuid")
    route3.result = {"itsystems": {"objects": []}}

    dn = "CN=foo"
    username_generator = AsyncMock()
    username_generator.generate_dn.return_value = dn
    dataloader.username_generator = username_generator

    with capture_logs() as cap_logs:
        result = await dataloader.make_mo_employee_dn(employee_uuid)
        assert result == dn
    log_events = [log["event"] for log in cap_logs]
    assert log_events == ["Generating DN for user"]


@pytest.mark.envvar({"LDAP_IT_SYSTEM": "ADUUID"})
async def test_make_mo_employee_dn_no_cpr(
    dataloader: MagicMock,
    graphql_mock: GraphQLMocker,
) -> None:
    employee_uuid = uuid4()
    cpr_number = None

    route1 = graphql_mock.query("read_employees")
    route1.result = {
        "employees": {
            "objects": [
                {
                    "validities": [
                        {
                            "uuid": employee_uuid,
                            "user_key": "ha",
                            "cpr_number": cpr_number,
                            "given_name": "Hans",
                            "surname": "Andersen",
                            "nickname_given_name": "",
                            "nickname_surname": "",
                            "validity": {
                                "from": None,
                                "to": None,
                            },
                        }
                    ]
                }
            ]
        }
    }

    route2 = graphql_mock.query("employee_refresh")
    route2.result = {"employee_refresh": {"objects": [employee_uuid]}}

    itsystem_uuid = uuid4()
    route3 = graphql_mock.query("read_itsystem_uuid")
    route3.result = {"itsystems": {"objects": [{"uuid": itsystem_uuid}]}}

    dn = "CN=foo"
    username_generator = AsyncMock()
    username_generator.generate_dn.return_value = dn
    dataloader.username_generator = username_generator

    ldap_uuid = uuid4()
    dataloader.ldapapi.get_ldap_unique_ldap_uuid = AsyncMock()
    dataloader.ldapapi.get_ldap_unique_ldap_uuid.return_value = ldap_uuid

    with capture_logs() as cap_logs:
        result = await dataloader.make_mo_employee_dn(employee_uuid)
        assert result == dn
    log_events = [log["event"] for log in cap_logs]
    assert log_events == ["Generating DN for user"]


def test_extract_unique_objectGUIDs(dataloader: DataLoader) -> None:
    ad_it_user_1 = ITUser(
        user_key=str(uuid4()),
        itsystem=uuid4(),
        person=uuid4(),
        validity={"start": datetime.datetime.today()},
    )
    ad_it_user_2 = ITUser(
        user_key=str(uuid4()),
        itsystem=uuid4(),
        person=uuid4(),
        validity={"start": datetime.datetime.today()},
    )

    objectGUIDs = dataloader.extract_unique_ldap_uuids([ad_it_user_1, ad_it_user_2])
    assert UUID(ad_it_user_1.user_key) in objectGUIDs
    assert UUID(ad_it_user_2.user_key) in objectGUIDs
    assert len(objectGUIDs) == 2

    ad_it_user_3 = ITUser(
        user_key="not_an_uuid",
        itsystem=uuid4(),
        person=uuid4(),
        validity={"start": datetime.datetime.today()},
    )
    with pytest.raises(ExceptionGroup) as exc_info:
        dataloader.extract_unique_ldap_uuids([ad_it_user_1, ad_it_user_2, ad_it_user_3])
    exception = one(exc_info.value.exceptions)
    assert str(exception) == "Non UUID IT-user user-key: not_an_uuid"


@pytest.mark.parametrize(
    "ldap_dns,expected",
    [
        ([], set()),
        (["CN=foo"], {"CN=foo"}),
        (["CN=foo", "CN=foo"], {"CN=foo"}),
        (["CN=foo", "CN=bar"], {"CN=foo", "CN=bar"}),
        (["CN=foo", "CN=bar", "CN=bar"], {"CN=foo", "CN=bar"}),
        (["CN=foo", "CN=bar", "CN=baz"], {"CN=foo", "CN=bar", "CN=baz"}),
    ],
)
async def test_convert_ldap_uuids_to_dns(
    dataloader: DataLoader,
    ldap_dns: list[str],
    expected: set[str],
) -> None:
    dataloader.ldapapi.get_ldap_dn = AsyncMock()  # type: ignore
    dataloader.ldapapi.get_ldap_dn.side_effect = ldap_dns

    dns = await dataloader.ldapapi.convert_ldap_uuids_to_dns(
        {cast(LDAPUUID, uuid4()) for _ in ldap_dns}
    )
    assert dns == expected


async def test_convert_ldap_uuids_to_dns_exception(dataloader: DataLoader) -> None:
    dataloader.ldapapi.get_ldap_dn = AsyncMock()  # type: ignore
    dataloader.ldapapi.get_ldap_dn.side_effect = ["CN=foo", ValueError("BOOM")]

    with pytest.raises(ExceptionGroup) as exc_info:
        await dataloader.ldapapi.convert_ldap_uuids_to_dns(
            {cast(LDAPUUID, uuid4()), cast(LDAPUUID, uuid4())}
        )
    assert "Exceptions during UUID2DN translation" in str(exc_info.value)
    assert len(exc_info.value.exceptions) == 1

    dataloader.ldapapi.get_ldap_dn.side_effect = [
        ValueError("BANG"),
        ValueError("BOOM"),
    ]

    with pytest.raises(ExceptionGroup) as exc_info:
        await dataloader.ldapapi.convert_ldap_uuids_to_dns(
            {cast(LDAPUUID, uuid4()), cast(LDAPUUID, uuid4())}
        )
    assert "Exceptions during UUID2DN translation" in str(exc_info.value)
    assert len(exc_info.value.exceptions) == 2


async def test_get_ldap_dn(dataloader: DataLoader):
    with patch(
        "mo_ldap_import_export.ldapapi.single_object_search",
        return_value={"dn": "CN=foo"},
    ):
        assert await dataloader.ldapapi.get_ldap_dn(cast(LDAPUUID, uuid4())) == "CN=foo"


async def test_get_ldap_unique_ldap_uuid(dataloader: DataLoader) -> None:
    uuid = uuid4()
    ldap_object = LdapObject(dn="foo", objectGUID=str(uuid))
    with patch(
        "mo_ldap_import_export.ldapapi.get_ldap_object", return_value=ldap_object
    ):
        assert await dataloader.ldapapi.get_ldap_unique_ldap_uuid("") == uuid


async def test_get_ldap_unique_ldap_uuid_no_objectguid(dataloader: DataLoader) -> None:
    ldap_object = LdapObject(dn="foo", objectGUID=[])
    with (
        patch(
            "mo_ldap_import_export.ldapapi.get_ldap_object",
            return_value=ldap_object,
        ),
        pytest.raises(NoObjectsReturnedException),
    ):
        await dataloader.ldapapi.get_ldap_unique_ldap_uuid("")


async def test_load_ldap_attribute_values(dataloader: DataLoader):
    responses = [
        {"attributes": {"foo": 1}},
        {"attributes": {"foo": "2"}},
        {"attributes": {"foo": []}},
    ]
    with patch(
        "mo_ldap_import_export.routes.paged_search",
        return_value=responses,
    ):
        settings = dataloader.settings
        ldap_connection = dataloader.ldapapi.ldap_connection
        values = await load_ldap_attribute_values(settings, ldap_connection, "foo")
        assert "1" in values
        assert "2" in values
        assert "[]" in values
        assert len(values) == 3


async def test_create_mo_class(dataloader: DataLoader):
    uuid = uuid4()
    existing_class_uuid = uuid4()

    moapi = MOAPI(dataloader.settings, dataloader.moapi.graphql_client)

    async def class_create(_) -> ClassCreateClassCreate:
        # Simulate creation time delay
        await asyncio.sleep(0.1)
        return ClassCreateClassCreate(uuid=uuid)

    moapi.graphql_client.class_create.side_effect = class_create  # type: ignore

    class_not_found_response = ReadClassUuidClasses(objects=[])
    class_exists_response = ReadClassUuidClasses(
        objects=[ReadClassUuidClassesObjects(uuid=existing_class_uuid)]
    )

    # Case1: The class does not exist yet
    moapi.graphql_client.read_class_uuid.return_value = class_not_found_response  # type: ignore
    assert await moapi.create_mo_class("", "", uuid4()) == uuid

    # Case2: The class already exists
    moapi.graphql_client.read_class_uuid.return_value = class_exists_response  # type: ignore
    assert await moapi.create_mo_class("", "", uuid4()) == existing_class_uuid

    # Case3: We call the function twice and the first one needs to wait for the second
    moapi.graphql_client.read_class_uuid.return_value = class_not_found_response  # type: ignore

    # Because of the lock, only one instance can run at the time.
    t1 = time.time()
    await asyncio.gather(
        moapi.create_mo_class("n", "user_key", uuid4()),
        moapi.create_mo_class("n", "user_key", uuid4()),
    )
    t2 = time.time()
    assert (t2 - t1) > 0.2  # each task takes 0.1 second


async def test_create_mo_job_function(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
) -> None:
    moapi = MOAPI(dataloader.settings, dataloader.moapi.graphql_client)

    route1 = graphql_mock.query("read_class_uuid_by_facet_and_class_user_key")
    route1.result = {"classes": {"objects": []}}

    uuid1 = uuid4()
    route2 = graphql_mock.query("read_facet_uuid")
    route2.result = {"facets": {"objects": [{"uuid": uuid1}]}}

    uuid2 = uuid4()

    moapi.create_mo_class = AsyncMock()  # type: ignore
    moapi.create_mo_class.return_value = uuid2

    assert await get_or_create_job_function_uuid(moapi, "foo") == str(uuid2)

    kwargs = moapi.create_mo_class.call_args_list[0].kwargs
    assert kwargs == {"name": "foo", "user_key": "foo", "facet_uuid": uuid1}


async def test_load_mo_facet_uuid(dataloader: DataLoader, graphql_mock: GraphQLMocker):
    uuid = uuid4()

    route = graphql_mock.query("read_facet_uuid")
    route.result = {"facets": {"objects": [{"uuid": uuid}]}}
    assert await dataloader.moapi.load_mo_facet_uuid("") == uuid
    assert route.called


async def test_load_mo_facet_uuid_multiple_facets(
    dataloader: DataLoader, graphql_mock: GraphQLMocker
):
    route = graphql_mock.query("read_facet_uuid")
    route.result = {
        "facets": {
            "objects": [
                {"uuid": uuid4()},
                {"uuid": uuid4()},
            ]
        }
    }
    with pytest.raises(MultipleObjectsReturnedException):
        await dataloader.moapi.load_mo_facet_uuid("")
    assert route.called


async def test_load_mo_facet_uuid_no_result(dataloader: DataLoader):
    dataloader.moapi.graphql_client.read_facet_uuid.return_value = parse_obj_as(  # type: ignore
        ReadFacetUuidFacets, {"objects": []}
    )
    result = await dataloader.moapi.load_mo_facet_uuid("")
    assert result is None


async def test_add_ldap_object(settings: Settings, ldap_connection: MagicMock) -> None:
    ldapapi = LDAPAPI(settings, ldap_connection)

    ldap_connection.get_response.return_value = [], {"type": "test"}

    await ldapapi.add_ldap_object(
        "CN=foo", attributes={"foo": [2]}, object_class=settings.ldap_object_class
    )
    ldap_connection.add.assert_called_once()  # type: ignore

    ldapapi.settings = MagicMock()  # type: ignore
    ldapapi.settings.add_objects_to_ldap = False
    ldapapi.settings.ldap_read_only = False

    with pytest.raises(ReadOnlyException) as exc:
        await ldapapi.add_ldap_object(
            "CN=foo", attributes={}, object_class=settings.ldap_object_class
        )
    assert "Adding LDAP objects is disabled" in str(exc.value)

    ldapapi.ldap_connection.reset_mock()  # type: ignore
    ldapapi.settings.add_objects_to_ldap = True
    ldapapi.ou_in_ous_to_write_to = MagicMock()  # type: ignore
    ldapapi.ou_in_ous_to_write_to.return_value = False

    with pytest.raises(ReadOnlyException) as exc:
        await ldapapi.add_ldap_object(
            "CN=foo", attributes={}, object_class=settings.ldap_object_class
        )
    assert "Not allowed to write to the specified OU" in str(exc.value)

    ldapapi.settings.ldap_read_only = True
    with pytest.raises(ReadOnlyException) as exc:
        await ldapapi.add_ldap_object(
            "CN=foo", attributes={}, object_class=settings.ldap_object_class
        )
    assert "LDAP connection is read-only" in str(exc.value)


def test_ou_in_ous_to_write_to(dataloader: DataLoader):
    settings_mock = MagicMock()
    settings_mock.ldap_ous_to_write_to = ["OU=foo", "OU=mucki,OU=bar"]
    dataloader.ldapapi.settings = settings_mock

    assert dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,OU=foo,DC=k") is True
    assert dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,OU=bar,DC=k") is False
    assert (
        dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,OU=mucki,OU=bar,DC=k")
        is True
    )
    assert dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,DC=k") is False

    settings_mock.ldap_ous_to_write_to = [""]
    dataloader.ldapapi.settings = settings_mock

    assert dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,OU=foo,DC=k") is True
    assert dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,OU=bar,DC=k") is True
    assert (
        dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,OU=mucki,OU=bar,DC=k")
        is True
    )
    assert dataloader.ldapapi.ou_in_ous_to_write_to("CN=Tobias,DC=k") is True


async def test_load_all_current_it_users_no_paged(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
) -> None:
    itsystem1_uuid = uuid4()

    route = graphql_mock.query("read_all_itusers")
    route.result = {
        "itusers": {
            "objects": [
                {
                    "validities": [
                        {
                            "itsystem_uuid": str(itsystem1_uuid),
                            "employee_uuid": str(uuid4()),
                            "user_key": "foo",
                            "uuid": str(uuid4()),
                        }
                    ]
                }
            ],
            "page_info": {"next_cursor": None},
        }
    }
    results = await load_all_current_it_users(
        dataloader.moapi.graphql_client, itsystem1_uuid
    )
    result = one(results)
    assert result["itsystem_uuid"] == str(itsystem1_uuid)
    assert result["user_key"] == "foo"


async def test_load_all_current_it_users_paged(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
) -> None:
    itsystem1_uuid = uuid4()

    query_results = [
        {
            "itusers": {
                "objects": [
                    {
                        "validities": [
                            {
                                "itsystem_uuid": str(itsystem1_uuid),
                                "employee_uuid": str(uuid4()),
                                "user_key": "foo",
                                "uuid": str(uuid4()),
                            }
                        ]
                    }
                ],
                "page_info": {"next_cursor": "VGhlIGNha2UgaXMgYSBsaWUK"},  # Fake cursor
            }
        },
        {
            "itusers": {
                "objects": [
                    {
                        "validities": [
                            {
                                "itsystem_uuid": str(itsystem1_uuid),
                                "employee_uuid": str(uuid4()),
                                "user_key": "bar",
                                "uuid": str(uuid4()),
                            }
                        ]
                    }
                ],
                "page_info": {"next_cursor": None},
            }
        },
    ]

    def pager(_: Any, route: Any) -> Response:
        # Gets called once per GraphQL httpx request
        # Each call increments route.call_count by one
        result = query_results[route.call_count]
        return Response(200, json={"data": jsonable_encoder(result)})

    route = graphql_mock.query("read_all_itusers")
    route.mock(side_effect=pager)
    results = await load_all_current_it_users(
        dataloader.moapi.graphql_client, itsystem1_uuid
    )
    assert len(results) == 2

    first, second = results
    assert first["itsystem_uuid"] == str(itsystem1_uuid)
    assert first["user_key"] == "foo"

    assert second["itsystem_uuid"] == str(itsystem1_uuid)
    assert second["user_key"] == "bar"


uuid_obj1 = uuid4()
uuid_obj2 = uuid4()
uuid_obj3 = uuid4()


@pytest.mark.freeze_time("2022-08-10")
@pytest.mark.parametrize(
    "validities,expected",
    [
        # One of the objects is valid today - return it
        (
            [
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": "2022-08-02T00:00:00+02:00",
                        "to": "2022-08-15T00:00:00+02:00",
                    },
                    "uuid": uuid_obj2,
                },
                {
                    "validity": {
                        "from": "2022-08-15T00:00:00+02:00",
                        "to": None,
                    },
                    "uuid": uuid_obj3,
                },
            ],
            uuid_obj2,
        ),
        # One of the objects is valid all the time - return it
        (
            [
                # NOTE: This combination should never exist, but we wanna test the codepath
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": None,
                        "to": None,
                    },
                    "uuid": uuid_obj3,
                },
            ],
            uuid_obj3,
        ),
        # No object is valid today - return the latest
        (
            [
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": "2022-08-15T00:00:00+02:00",
                        "to": None,
                    },
                    "uuid": uuid_obj3,
                },
            ],
            uuid_obj3,
        ),
        # No valid current object - return the latest
        (
            [
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": "2022-08-15T00:00:00+02:00",
                        "to": "2022-08-20T00:00:00+02:00",
                    },
                    "uuid": uuid_obj2,
                },
            ],
            uuid_obj2,
        ),
        # One of the objects is valid today (without to-date) - return it
        (
            [
                {
                    "validity": {
                        "from": "2022-08-01T00:00:00+02:00",
                        "to": "2022-08-02T00:00:00+02:00",
                    },
                    "uuid": uuid_obj1,
                },
                {
                    "validity": {
                        "from": "2022-08-02T00:00:00+02:00",
                        "to": None,
                    },
                    "uuid": uuid_obj2,
                },
            ],
            uuid_obj2,
        ),
        # One of the objects is valid today (without from-date)- return it
        (
            [
                {
                    "validity": {
                        "from": None,
                        "to": "2022-08-15T00:00:00+02:00",
                    },
                    "uuid": uuid_obj2,
                },
                {
                    "validity": {
                        "from": "2022-08-15T00:00:00+02:00",
                        "to": None,
                    },
                    "uuid": uuid_obj3,
                },
            ],
            uuid_obj2,
        ),
    ],
)
def test_extract_latest_object(
    validities: list[dict[str, Any]], expected: UUID
) -> None:
    class Validity(BaseModel):
        from_: datetime.datetime | None = Field(alias="from")
        to: datetime.datetime | None

    class ValidityUUID(BaseModel):
        uuid: UUID
        validity: Validity

    obj_validities = parse_obj_as(list[ValidityUUID], validities)
    result = extract_current_or_latest_validity(obj_validities)
    assert result is not None
    assert result.uuid == expected


def test_extract_latest_object_empty() -> None:
    result = extract_current_or_latest_validity([])
    assert result is None


async def test_create_or_edit_mo_objects(dataloader: DataLoader) -> None:
    moapi = dataloader.moapi

    # One object is created and another is edited
    person = uuid4()
    address_type = uuid4()
    create = Address(
        value="foo",
        address_type=address_type,
        validity={"start": "2021-01-01T00:00:00"},
        person=person,
    )
    edit = Address(
        value="bar",
        address_type=address_type,
        validity={"start": "2021-01-01T00:00:00"},
        person=person,
    )
    terminate = Termination(mo_class=Address, uuid=uuid4(), at=datetime.datetime.now())

    objs = [(create, Verb.CREATE), (edit, Verb.EDIT), (terminate, Verb.TERMINATE)]

    moapi.create = AsyncMock()  # type: ignore
    moapi.edit = AsyncMock()  # type: ignore
    moapi.terminate = AsyncMock()  # type: ignore

    await moapi.create_or_edit_mo_objects(objs)  # type: ignore
    moapi.create.assert_called_once_with([create])
    moapi.edit.assert_called_once_with([edit])
    moapi.terminate.assert_called_once_with([terminate])


@pytest.mark.parametrize(
    "cpr_number,dns,expected",
    [
        # No CPR number -> no DNs
        (None, None, set()),
        # CPR number, but no accounts -> no DNs
        ("0101700000", [], set()),
        # CPR number and one account -> one DN
        ("0101700000", ["CN=foo"], {"CN=foo"}),
        # CPR number and two accounts -> two DN
        ("0101700000", ["CN=foo", "CN=bar"], {"CN=foo", "CN=bar"}),
    ],
)
async def test_find_mo_employee_dn_by_cpr_number(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
    cpr_number: str | None,
    dns: list[str] | None,
    expected: set[str] | str,
) -> None:
    employee_uuid = uuid4()
    employee = {
        "uuid": employee_uuid,
        "user_key": "user_key",
        "cpr_number": cpr_number,
        "given_name": "first_name",
        "surname": "last_name",
        "nickname_given_name": "",
        "nickname_surname": "",
        "validity": {"to": None},
    }
    route = graphql_mock.query("read_employees")
    route.result = {"employees": {"objects": [{"validities": [employee]}]}}

    dataloader.ldapapi.cpr2dns = AsyncMock()  # type: ignore
    dataloader.ldapapi.cpr2dns.return_value = {dn for dn in (dns or [])}

    result = await dataloader.find_mo_employee_dn_by_cpr_number(employee_uuid)
    assert result == expected

    if dns is not None:
        dataloader.ldapapi.cpr2dns.assert_called_once_with(cpr_number)


@pytest.mark.envvar({"LDAP_IT_SYSTEM": "ADUUID"})
async def test_find_mo_employee_dn_by_itsystem_no_itsystem(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
) -> None:
    employee_uuid = uuid4()

    route = graphql_mock.query("read_itsystem_uuid")
    route.result = {"itsystems": {"objects": []}}

    result = await dataloader.find_mo_employee_dn_by_itsystem(employee_uuid)
    assert result == set()


@pytest.mark.envvar({"LDAP_IT_SYSTEM": "ADUUID"})
async def test_find_mo_employee_dn_by_itsystem_no_match(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
) -> None:
    employee_uuid = uuid4()
    itsystem_uuid = uuid4()

    route1 = graphql_mock.query("read_itsystem_uuid")
    route1.result = {"itsystems": {"objects": [{"uuid": itsystem_uuid}]}}

    route2 = graphql_mock.query("read_ituser_by_employee_and_itsystem_uuid")
    route2.result = {"itusers": {"objects": []}}

    result = await dataloader.find_mo_employee_dn_by_itsystem(employee_uuid)
    assert result == set()


@pytest.mark.envvar({"LDAP_IT_SYSTEM": "ADUUID"})
async def test_find_mo_employee_dn_by_itsystem(
    dataloader: DataLoader,
    graphql_mock: GraphQLMocker,
) -> None:
    employee_uuid = uuid4()
    itsystem_uuid = uuid4()
    ituser_uuid = uuid4()

    route1 = graphql_mock.query("read_itsystem_uuid")
    route1.result = {"itsystems": {"objects": [{"uuid": itsystem_uuid}]}}

    route2 = graphql_mock.query("read_ituser_by_employee_and_itsystem_uuid")
    route2.result = {"itusers": {"objects": [{"uuid": ituser_uuid}]}}

    route3 = graphql_mock.query("read_itusers")
    route3.result = {
        "itusers": {
            "objects": [
                {
                    "validities": [
                        {
                            "user_key": ituser_uuid,
                            "validity": {"from": "1970-01-01T00:00:00Z"},
                            "employee_uuid": employee_uuid,
                            "itsystem_uuid": itsystem_uuid,
                            "engagement_uuid": None,
                        }
                    ]
                }
            ]
        }
    }

    dn = "CN=foo"
    dataloader.ldapapi.get_ldap_dn = AsyncMock()  # type: ignore
    dataloader.ldapapi.get_ldap_dn.return_value = dn

    result = await dataloader.find_mo_employee_dn_by_itsystem(employee_uuid)
    assert result == {dn}

    dataloader.ldapapi.get_ldap_dn.assert_called_once_with(ituser_uuid)
