# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import UTC
from datetime import datetime
from uuid import UUID
from uuid import uuid4

import pytest
from fastramqpi.ramqp.utils import RequeueMessage

from mo_ldap_import_export.config import Settings
from mo_ldap_import_export.moapi import get_primary_engagement
from mo_ldap_import_export.types import EmployeeUUID
from mo_ldap_import_export.main import GRAPHQL_VERSION
from tests.graphql_mocker import GraphQLMocker
from mo_ldap_import_export.autogenerated_graphql_client import GraphQLClient

engagement_uuid1 = uuid4()
engagement_uuid2 = uuid4()
engagement_uuid3 = uuid4()

past = {"from_": "1970-01-01T00:00:00Z", "to": "1980-01-01T00:00:00Z"}
current = {"from_": "1970-01-01T00:00:00Z", "to": None}
future = {"from_": "9970-01-01T00:00:00Z", "to": None}


def construct_validity(
    fraction: int | None,
    user_key: str,
    validity: dict[str, str | None],
    uuid: UUID,
    engagement_type: UUID | None = None,
) -> dict:
    return {
        "fraction": fraction,
        "user_key": user_key,
        "uuid": uuid,
        "validity": validity,
        "engagement_type": {"uuid": engagement_type or uuid4()},
    }


@pytest.mark.parametrize(
    "objects,expected,exclude_engagement_types",
    [
        # No objects, no validities
        ([], None, None),
        # One engagement, should be primary
        (
            [{"validities": [construct_validity(100, "a", current, engagement_uuid1)]}],
            engagement_uuid1,
            None,
        ),
        # Two engagements, highest fraction wins
        (
            [
                {
                    "validities": [
                        construct_validity(50, "a", current, engagement_uuid1),
                        construct_validity(100, "b", current, engagement_uuid2),
                    ]
                }
            ],
            engagement_uuid2,
            None,
        ),
        # Two engagements, same fraction, highest user_key wins
        (
            [
                {
                    "validities": [
                        construct_validity(100, "a", current, engagement_uuid1),
                        construct_validity(100, "b", current, engagement_uuid2),
                    ]
                }
            ],
            engagement_uuid2,
            None,
        ),
        # Three engagements, one with None fraction
        (
            [
                {
                    "validities": [
                        construct_validity(None, "a", current, engagement_uuid1),
                        construct_validity(100, "b", current, engagement_uuid2),
                        construct_validity(50, "c", current, engagement_uuid3),
                    ]
                }
            ],
            engagement_uuid2,
            None,
        ),
        # One engagement in the past, should be ignored
        (
            [{"validities": [construct_validity(100, "a", past, engagement_uuid1)]}],
            None,
            None,
        ),
        # One engagement in the future, should be considered
        (
            [{"validities": [construct_validity(100, "a", future, engagement_uuid1)]}],
            engagement_uuid1,
            None,
        ),
        # One past, one current engagement
        (
            [
                {
                    "validities": [
                        construct_validity(100, "a", past, engagement_uuid1),
                        construct_validity(50, "b", current, engagement_uuid2),
                    ]
                }
            ],
            engagement_uuid2,
            None,
        ),
        # Test exclude_engagement_types
        (
            [
                {
                    "validities": [
                        construct_validity(
                            100, "a", current, engagement_uuid1, engagement_type=UUID(int=1)
                        ),
                        construct_validity(50, "b", current, engagement_uuid2),
                    ]
                }
            ],
            engagement_uuid2,
            {UUID(int=1)},
        ),
    ],
)
async def test_get_primary_engagement(
    graphql_mock: GraphQLMocker,
    objects: list[dict],
    expected: UUID | str | None,
    exclude_engagement_types: set[UUID] | None,
    minimal_valid_settings: Settings,
) -> None:
    graphql_client = GraphQLClient(f"http://example.com/graphql/v{GRAPHQL_VERSION}")
    employee_uuid = EmployeeUUID(uuid4())

    route = graphql_mock.query("read_engagements_for_primary_calculation")
    route.result = {"engagements": {"objects": objects}}

    result = await get_primary_engagement(
        graphql_client,
        employee_uuid,
        minimal_valid_settings,
        exclude_engagement_types,
    )
    assert result == expected
    assert route.called
