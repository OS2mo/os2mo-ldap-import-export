# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from collections.abc import Awaitable
from collections.abc import Callable
from uuid import uuid4

import pytest
from fastramqpi.context import Context
from more_itertools import only
from structlog.testing import capture_logs

from mo_ldap_import_export.autogenerated_graphql_client import GraphQLClient
from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    ITSystemFilter,
)
from mo_ldap_import_export.autogenerated_graphql_client.input_types import ITUserFilter
from mo_ldap_import_export.config import Settings
from mo_ldap_import_export.import_export import SyncTool
from mo_ldap_import_export.ldap import ldap_add
from mo_ldap_import_export.ldapapi import LDAPAPI
from mo_ldap_import_export.types import LDAPUUID
from mo_ldap_import_export.types import EmployeeUUID
from mo_ldap_import_export.utils import combine_dn_strings


@pytest.fixture
def get_ituser(
    graphql_client: GraphQLClient,
) -> Callable[[], Awaitable[LDAPUUID | None]]:
    async def inner() -> LDAPUUID | None:
        settings = Settings()
        users = await graphql_client._testing__ituser_read(
            filter=ITUserFilter(
                itsystem=ITSystemFilter(
                    user_keys=[settings.ldap_it_system], from_date=None, to_date=None
                ),
                from_date=None,
                to_date=None,
            )
        )
        user = only(users.objects)
        if not user:
            return None
        validity = only(user.validities)
        if not validity:
            return None
        return LDAPUUID(validity.user_key)

    return inner


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "LDAP_IT_SYSTEM": "non_existent",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_ensure_ituser_link_invalid_itsystem(
    context: Context, get_ituser: Callable[[], Awaitable[str]]
) -> None:
    sync_tool: SyncTool = context["user_context"]["sync_tool"]
    with capture_logs() as cap_logs:
        await sync_tool.ensure_ituser_link(EmployeeUUID(uuid4()), "CN=foo")
    assert await get_ituser() is None

    assert cap_logs == [
        {
            "event": "UUID Not found",
            "log_level": "info",
            "suggestion": "Does the 'non_existent' it-system exist?",
        }
    ]


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "LDAP_IT_SYSTEM": "ADUUID",
    }
)
async def test_ensure_ituser_link(
    context: Context,
    get_ituser: Callable[[], Awaitable[str]],
    ldap_org_unit: list[str],
    mo_person: EmployeeUUID,
) -> None:
    sync_tool: SyncTool = context["user_context"]["sync_tool"]
    ldapapi: LDAPAPI = context["user_context"]["dataloader"].ldapapi

    # Verify required settings are set
    settings = Settings()
    assert settings.ldap_it_system is not None
    assert settings.ldap_unique_id_field != ""

    # Add a user to LDAP and fetch its entry UUID
    person_dn = combine_dn_strings(["uid=abk"] + ldap_org_unit)
    await ldap_add(
        ldapapi.connection,
        dn=person_dn,
        object_class=["top", "person", "organizationalPerson", "inetOrgPerson"],
        attributes={"cn": "Aage Bach Klarskov", "sn": "Bach Klarskov"},
    )
    ldap_uuid = await ldapapi.get_ldap_unique_ldap_uuid(person_dn)

    # Create
    with capture_logs() as cap_logs:
        await sync_tool.ensure_ituser_link(mo_person, person_dn)
    assert await get_ituser() == ldap_uuid
    assert {"event": "Creating link as it is missing", "log_level": "info"} in cap_logs

    # Edit
    with capture_logs() as cap_logs:
        await sync_tool.ensure_ituser_link(mo_person, person_dn)
    assert await get_ituser() == ldap_uuid
    assert {
        "event": "Not creating link as it already exists",
        "log_level": "info",
    } in cap_logs
