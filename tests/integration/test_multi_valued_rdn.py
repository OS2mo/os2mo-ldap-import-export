# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import json
from collections.abc import Awaitable
from collections.abc import Callable

import pytest
from ldap3 import Connection
from ldap3.utils.dn import parse_dn

from mo_ldap_import_export.autogenerated_graphql_client import EmployeeCreateInput
from mo_ldap_import_export.autogenerated_graphql_client import GraphQLClient
from mo_ldap_import_export.config import Settings
from mo_ldap_import_export.ldap import get_ldap_object
from mo_ldap_import_export.ldapapi import LDAPAPI
from mo_ldap_import_export.types import DN
from mo_ldap_import_export.types import CPRNumber
from mo_ldap_import_export.types import EmployeeUUID
from mo_ldap_import_export.utils import combine_dn_strings


@pytest.mark.parametrize(
    "dn, expected",
    [
        # CN upper and lower
        # This verifies that casing is persisted
        (
            "CN=common name",
            [
                ("CN", "common name", ""),
            ],
        ),
        (
            "cn=common name",
            [
                ("cn", "common name", ""),
            ],
        ),
        # CN + OU upper, lower and mixed
        # This verifies that case-mixing is okay
        (
            "CN=common name,OU=organisation unit",
            [
                ("CN", "common name", ","),
                ("OU", "organisation unit", ""),
            ],
        ),
        (
            "cn=common name,ou=organisation unit",
            [
                ("cn", "common name", ","),
                ("ou", "organisation unit", ""),
            ],
        ),
        (
            "CN=common name,ou=organisation unit",
            [
                ("CN", "common name", ","),
                ("ou", "organisation unit", ""),
            ],
        ),
        (
            "cn=common name,OU=organisation unit",
            [
                ("cn", "common name", ","),
                ("OU", "organisation unit", ""),
            ],
        ),
        # CN + OU + DC upper and lower
        # This verifies that multiple layers are parsed as expected
        (
            "CN=common name,OU=organisation unit,DC=kommune,DC=dk",
            [
                ("CN", "common name", ","),
                ("OU", "organisation unit", ","),
                ("DC", "kommune", ","),
                ("DC", "dk", ""),
            ],
        ),
        (
            "cn=common name,ou=organisation unit,dc=kommune,dc=dk",
            [
                ("cn", "common name", ","),
                ("ou", "organisation unit", ","),
                ("dc", "kommune", ","),
                ("dc", "dk", ""),
            ],
        ),
        # Multi-valued RDN; CN + UID upper, lower and mixed
        # This verifies that multi-valued RDNs are parsed into separate entities
        # It also verifies that case-mixing within multi-valued RDNs is okay
        (
            "cn=common name+uid=unique_id",
            [
                ("cn", "common name", "+"),
                ("uid", "unique_id", ""),
            ],
        ),
        (
            "CN=common name+UID=unique_id",
            [
                ("CN", "common name", "+"),
                ("UID", "unique_id", ""),
            ],
        ),
        (
            "CN=common name+uid=unique_id",
            [
                ("CN", "common name", "+"),
                ("uid", "unique_id", ""),
            ],
        ),
        (
            "cn=common name+UID=unique_id",
            [
                ("cn", "common name", "+"),
                ("UID", "unique_id", ""),
            ],
        ),
        # Multi-valued RDN in across multiple attributes
        # This verifies that multi-valued RDNs can be used anywhere in the DN
        (
            "cn=cn+uid=uid,ou=ou1+uid=uid2,ou=ou2+uid=uid3,dc=kommune,dc=dk",
            [
                ("cn", "cn", "+"),
                ("uid", "uid", ","),
                ("ou", "ou1", "+"),
                ("uid", "uid2", ","),
                ("ou", "ou2", "+"),
                ("uid", "uid3", ","),
                ("dc", "kommune", ","),
                ("dc", "dk", ""),
            ],
        ),
        # Triple-valued RDN in first attribute
        # This verifies that we are not limited to two values pairs in the RDN
        (
            "cn=cn+uid=uid+mail=a@b.com,ou=ou,dc=kommune,dc=dk",
            [
                ("cn", "cn", "+"),
                ("uid", "uid", "+"),
                ("mail", "a@b.com", ","),
                ("ou", "ou", ","),
                ("dc", "kommune", ","),
                ("dc", "dk", ""),
            ],
        ),
    ],
)
def test_parse_dn_handles_multi_valued_rdns(
    dn: DN, expected: list[tuple[str, str, str]]
) -> None:
    """Test that parse_dn handles multi-valued RDNs as expected.

    Multi-valued RDNs are RDNs with a + sign separator between two attribute types.

    They are specified by RFC4514 Section 2.2, which states:

    > When converting from an ASN.1 RelativeDistinguishedName to a string,
    > the output consists of the string encodings of each AttributeTypeAndValue
    > (according to Section 2.3), in any order.
    > Where there is a multi-valued RDN, the outputs from adjoining
    > AttributeTypeAndValues are separated by a plus sign ('+' U+002B) character.

    This test really only tests ldap3 functionality, but it is added here to document
    the behavior of the library, as the documentation for DN parsing in the library
    only contains a section header and the "tbd" string:

    * https://ldap3.readthedocs.io/en/latest/dn.html
    """
    assert parse_dn(dn) == expected


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "CONVERSION_MAPPING": json.dumps(
            {
                "mo2ldap": """
                    {% set mo_employee = load_mo_employee(uuid, current_objects_only=False) %}
                    {{
                        {
                            "employeeNumber": mo_employee.cpr_number,
                            "uid": mo_employee.cpr_number,
                            "cn": mo_employee.given_name + " " + mo_employee.surname,
                            "sn": mo_employee.surname,
                        }|tojson
                    }}
                """,
            }
        ),
    }
)
@pytest.mark.usefixtures("test_client")
async def test_renaming_multi_valued_rdns(
    trigger_sync: Callable[[EmployeeUUID], Awaitable[None]],
    graphql_client: GraphQLClient,
    ldap_connection: Connection,
    ldap_api: LDAPAPI,
    ldap_org_unit: list[str],
) -> None:
    settings = Settings()
    ldapapi = LDAPAPI(settings, ldap_connection)

    cpr = "0101700000"
    uid = "42"
    # Construct the person with a multi-valued RDN
    person_dn = combine_dn_strings([f"employeeNumber={cpr}+uid={uid}"] + ldap_org_unit)

    await ldap_api.ldap_connection.ldap_add(
        dn=person_dn,
        object_class=["top", "person", "organizationalPerson", "inetOrgPerson"],
        attributes={"cn": "Aage Bach Klarskov", "sn": "Bach Klarskov"},
    )

    # The entity will change its DN, so we reference it using the entryUUID instead
    entry_uuid = await ldapapi.get_ldap_unique_ldap_uuid(person_dn)

    # Check that the entity got the expected DN
    assert await ldapapi.get_ldap_dn(entry_uuid) == person_dn

    # Check that the entity has the expected attributes
    ldap_object = await get_ldap_object(ldap_connection, person_dn)
    assert hasattr(ldap_object, "cn")
    assert hasattr(ldap_object, "employeeNumber")
    assert hasattr(ldap_object, "uid")
    assert ldap_object.cn == ["Aage Bach Klarskov"]
    # Check that we can read the attributes set by the RDN
    assert ldap_object.employeeNumber == cpr
    assert ldap_object.uid == [uid]

    # Create a person with a new name and synchronize it
    mo_person = await graphql_client.person_create(
        input=EmployeeCreateInput(
            cpr_number=CPRNumber(cpr),
            given_name="given_name",
            surname="surname",
        )
    )
    await trigger_sync(EmployeeUUID(mo_person.uuid))

    # The DN should now have changed, since we changed 'uid' to be the CPR number
    new_dn = await ldapapi.get_ldap_dn(entry_uuid)
    assert new_dn is not None
    assert new_dn != person_dn

    # We expect the RDN to keep its format, only changing the values within it
    expected_dn = combine_dn_strings(
        [f"employeeNumber={cpr}+uid={cpr}"] + ldap_org_unit
    )
    assert new_dn == expected_dn
