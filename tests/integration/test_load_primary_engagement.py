# SPDX-FileCopyrightText: 2019-2020 Magenta ApS
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from unittest.mock import ANY
from uuid import UUID
from uuid import uuid4

import pytest
from fastramqpi.context import Context
from fastramqpi.ramqp.utils import RequeueMessage
from structlog.testing import capture_logs

from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    EngagementCreateInput,
)
from mo_ldap_import_export.depends import GraphQLClient
from mo_ldap_import_export.environments import load_primary_engagement
from mo_ldap_import_export.utils import MO_TZ


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
) -> None:
    title = "create"
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key=title,
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            extension_1=title,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]
    result = await load_primary_engagement(dataloader, mo_person)
    assert result is not None
    assert result.dict(exclude_none=True) == {
        "engagement_type": {"uuid": ansat},
        "extension_1": title,
        "job_function": {"uuid": jurist},
        "org_unit": {"uuid": mo_org_unit},
        "person": {"uuid": mo_person},
        "primary": {"uuid": primary},
        "type_": "engagement",
        "user_key": title,
        "uuid": ANY,
        "validity": {"from_date": datetime(2001, 2, 3, 0, 0, tzinfo=MO_TZ)},
    }


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_deleted(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
) -> None:
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="terminated_engagement",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            validity={"from": "2001-02-03T04:05:06Z", "to": "2002-03-04T05:06:07Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]
    with capture_logs() as cap_logs:
        result = await load_primary_engagement(dataloader, mo_person)
    assert result is None

    events = [m["event"] for m in cap_logs]
    assert events == [
        "Found primary engagement",
        "Returning delete=True because to_date <= current_date",
        "Primary engagement is terminated",
    ]


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_no_primary(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    non_primary: UUID,
) -> None:
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="non_primary_engagement",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=non_primary,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]
    with pytest.raises(RequeueMessage) as exc_info:
        await load_primary_engagement(dataloader, mo_person)
    assert "Waiting for primary engagement to be decided" in str(exc_info.value)


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
@pytest.mark.xfail(
    reason="MO is lying about multiple primaries, and just returns a random one"
)
async def test_load_primary_engagement_multiple_primaries(
    graphql_client: GraphQLClient,
    context: Context,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
) -> None:
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="engagement1",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            validity={"from": "2000-02-03T04:05:06Z"},
        )
    )
    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="engagement2",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            validity={"from": "2000-02-03T04:05:06Z"},
        )
    )

    dataloader = context["user_context"]["dataloader"]
    with pytest.raises(RequeueMessage) as exc_info:
        await load_primary_engagement(dataloader, mo_person)
    assert "Waiting for multiple primary engagements to be resolved" in str(
        exc_info.value
    )


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_invalid_employee(context: Context) -> None:
    dataloader = context["user_context"]["dataloader"]
    employee_uuid = uuid4()
    with capture_logs() as cap_logs:
        result = await load_primary_engagement(dataloader, employee_uuid)
    assert result is None

    events = [m["event"] for m in cap_logs]
    assert events == [
        "No engagement validities found",
        "Could not find primary engagement UUID",
    ]


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_load_primary_engagement_no_engagement(
    context: Context, mo_person: UUID
) -> None:
    dataloader = context["user_context"]["dataloader"]
    with capture_logs() as cap_logs:
        result = await load_primary_engagement(dataloader, mo_person)
    assert result is None

    events = [m["event"] for m in cap_logs]
    assert events == [
        "No engagement validities found",
        "Could not find primary engagement UUID",
    ]
