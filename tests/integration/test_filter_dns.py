# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import json
from collections.abc import Awaitable
from collections.abc import Callable
from unittest.mock import AsyncMock

import pytest
from ldap3 import Connection

from mo_ldap_import_export.autogenerated_graphql_client import EmployeeCreateInput
from mo_ldap_import_export.autogenerated_graphql_client import GraphQLClient
from mo_ldap_import_export.depends import Settings
from mo_ldap_import_export.ldap import filter_dns
from mo_ldap_import_export.ldapapi import LDAPAPI
from mo_ldap_import_export.types import DN
from mo_ldap_import_export.types import EmployeeUUID
from mo_ldap_import_export.utils import combine_dn_strings
from tests.integration.conftest import AddLdapPerson


@pytest.mark.usefixtures("minimal_valid_environmental_variables")
@pytest.mark.parametrize("input_dns", [set(), {"CN=foo"}, {"CN=foo", "CN=bar"}])
async def test_filter_dns_no_filter(input_dns: set[DN]) -> None:
    ldap_connection = AsyncMock()

    settings = Settings()
    assert settings.discriminator_filter is None

    output_dns = await filter_dns(settings, ldap_connection, input_dns)
    assert input_dns == output_dns


@pytest.mark.usefixtures("minimal_valid_environmental_variables")
async def test_filter_dns_no_fields() -> None:
    ldap_connection = AsyncMock()

    settings = Settings()
    assert settings.discriminator_filter is None
    settings = settings.copy(update={"discriminator_filter": "True"})
    assert settings.discriminator_filter == "True"

    with pytest.raises(AssertionError) as exc_info:
        await filter_dns(settings, ldap_connection, {"CN=foo"})
    assert "discriminator_fields must be set" in str(exc_info.value)


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "True",
        "DISCRIMINATOR_VALUES": '["True"]',
        "DISCRIMINATOR_FIELDS": '["title"]',
    }
)
@pytest.mark.parametrize(
    "filtered",
    [
        # Filter always rejects
        pytest.param(True, marks=pytest.mark.envvar({"DISCRIMINATOR_FILTER": "False"})),
        # Filter always accepts
        pytest.param(False, marks=pytest.mark.envvar({"DISCRIMINATOR_FILTER": "True"})),
        # Filter accepts if title is correct (using value)
        pytest.param(
            False,
            marks=pytest.mark.envvar(
                {"DISCRIMINATOR_FILTER": '{{ value == "Skole underviser" }}'}
            ),
        ),
        pytest.param(
            True,
            marks=pytest.mark.envvar(
                {"DISCRIMINATOR_FILTER": '{{ value == "Software udvikler" }}'}
            ),
        ),
        # Filter accepts if substring in title is found (using title)
        pytest.param(
            False,
            marks=pytest.mark.envvar(
                {"DISCRIMINATOR_FILTER": '{{ "Skole" in title }}'}
            ),
        ),
        pytest.param(
            True,
            marks=pytest.mark.envvar(
                {"DISCRIMINATOR_FILTER": '{{ "Software" in title }}'}
            ),
        ),
    ],
)
async def test_filter_dns(
    ldap_connection: Connection, ldap_person_dn: DN, filtered: bool
) -> None:
    settings = Settings()
    result = await filter_dns(settings, ldap_connection, {ldap_person_dn})
    expected = set() if filtered else {ldap_person_dn}
    assert result == expected


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "True",
        "DISCRIMINATOR_VALUES": '["True"]',
        "DISCRIMINATOR_FIELDS": '["employeeNumber"]',
        # Only accept users born before the moon landing (by date)
        "DISCRIMINATOR_FILTER": """
        {% set number = value|int %}
        {% set rest = (number / 10000)|int %}
        {% set code = number % 10000 %}

        {% set year = rest % 100 %}
        {% set rest = (rest / 100)|int %}

        {% set month = rest % 100 %}
        {% set rest = (rest / 100)|int %}

        {% set day = rest % 100 %}
        {% set rest = (rest / 100)|int %}

        {% if rest %}
            Invalid CPR number: {{ value }}
        {% endif %}

        {% if code < 4000 %}
            {% set century = 1900 %}
        {% elif code < 5000 %}
            {% set century = 2000 if year <= 36 else 1900 %}
        {% elif code < 9000 %}
            {% set century = 2000 if year <= 57 else 1800 %}
        {% else %}
            {% set century = 2000 if year <= 36 else 1900 %}
        {% endif %}

        {% set year = century + year %}
        {{ year < 1969 or (year <= 1969 and month <= 7 and day <= 20) }}
        """,
    }
)
async def test_filter_dns_accepts_pre_moonlanding(
    ldap_connection: Connection, add_ldap_person: AddLdapPerson
) -> None:
    # Born 24th of December 1885
    b18 = combine_dn_strings(await add_ldap_person("b18", "2412855038"))
    # Born 18th of July 1969
    b19 = combine_dn_strings(await add_ldap_person("b19", "1907690004"))
    # Born 21st of July 1969
    a19 = combine_dn_strings(await add_ldap_person("a19", "2107690002"))
    # Born 11th of September 2001
    a20 = combine_dn_strings(await add_ldap_person("a20", "1109014008"))

    # Check that only b18 and b19 survives our filter
    settings = Settings()
    result = await filter_dns(settings, ldap_connection, {b18, b19, a19, a20})
    assert result == {b18, b19}


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "DISCRIMINATOR_FIELDS": json.dumps(["carLicense"]),
        "DISCRIMINATOR_FILTER": '{{ value is none or "No" not in value }}',
        "DISCRIMINATOR_VALUES": json.dumps(["True"]),
        "CONVERSION_MAPPING": json.dumps(
            {
                "mo2ldap": """
                    {% set mo_employee = load_mo_employee(uuid, current_objects_only=False) %}
                    {{
                        {
                            "employeeNumber": mo_employee.cpr_number,
                            "givenName": mo_employee.given_name,
                            "sn": mo_employee.surname,
                        }|tojson
                    }}
                """,
            }
        ),
    }
)
@pytest.mark.usefixtures("test_client")
async def test_to_ldap_discriminated_account(
    graphql_client: GraphQLClient,
    trigger_sync: Callable[[EmployeeUUID], Awaitable[None]],
    ldap_api: LDAPAPI,
    ldap_org_unit: list[str],
) -> None:
    cpr_number = "2108613133"
    given_name = "Alice"
    surname = "Allman"

    # Create discriminated LDAP account
    discriminated_dn = ["cn=" + " ".join([given_name, surname])] + ldap_org_unit
    await ldap_api.ldap_connection.ldap_add(
        combine_dn_strings(discriminated_dn),
        object_class=["top", "person", "organizationalPerson", "inetOrgPerson"],
        attributes={
            "objectClass": ["top", "person", "organizationalPerson", "inetOrgPerson"],
            "employeeNumber": cpr_number,
            "givenName": given_name,
            "sn": surname,
            # This causes the account to be discriminated away
            "carLicense": "No",
        },
    )

    # Create MO employee
    mo_employee = await graphql_client.person_create(
        input=EmployeeCreateInput(
            cpr_number=cpr_number, given_name=given_name, surname=surname
        )
    )

    # Trigger synchronization
    await trigger_sync(EmployeeUUID(mo_employee.uuid))

    # Check result, we expect 2 accounts now, the discriminated and a new one
    response, _ = await ldap_api.ldap_connection.ldap_search(
        search_base=combine_dn_strings(ldap_org_unit),
        search_filter=f"(employeeNumber={cpr_number})",
        attributes=["*"],
    )
    dns = {result["dn"] for result in response}
    assert dns == {
        combine_dn_strings(discriminated_dn),
        combine_dn_strings(
            ["cn=" + " ".join([given_name, surname]) + "_2"] + ldap_org_unit
        ),
    }
