# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import json
from datetime import UTC
from datetime import datetime
from datetime import timedelta
from datetime import timezone
from uuid import UUID

import pytest
from httpx import AsyncClient

from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    EngagementCreateInput,
)
from mo_ldap_import_export.depends import Connection
from mo_ldap_import_export.depends import GraphQLClient
from mo_ldap_import_export.environments import get_employment_interval
from mo_ldap_import_export.ldap import get_ldap_object
from mo_ldap_import_export.utils import MO_TZ
from mo_ldap_import_export.utils import combine_dn_strings

TZMAX = datetime.max.replace(tzinfo=MO_TZ)


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
@pytest.mark.parametrize(
    "intervals,start,end",
    [
        # No engagement
        ([], None, None),
        # Start-date only
        ([(datetime(2001, 2, 3), None)], datetime(2001, 2, 3, tzinfo=MO_TZ), TZMAX),
        # Start-date and end-date
        (
            [(datetime(2001, 2, 3), datetime(2020, 3, 1))],
            datetime(2001, 2, 3, tzinfo=MO_TZ),
            datetime(2020, 3, 1, tzinfo=MO_TZ),
        ),
        # Multiple engagements, only start-dates, all infinite
        (
            [
                (datetime(2001, 2, 3), None),
                (datetime(2020, 3, 1), None),
                (datetime(1970, 1, 1), None),
            ],
            datetime(1970, 1, 1, tzinfo=MO_TZ),
            TZMAX,
        ),
        # Multiple engagements, start-dates and end-dates, one infinite
        (
            [
                (datetime(2001, 2, 3), datetime(2002, 4, 16)),
                (datetime(2020, 3, 1), datetime(2026, 2, 1)),
                (datetime(1970, 1, 1), None),
            ],
            datetime(1970, 1, 1, tzinfo=MO_TZ),
            TZMAX,
        ),
        # Multiple engagements, start-dates and end-dates, no infinite
        (
            [
                (datetime(2001, 2, 3), datetime(2002, 4, 16)),
                (datetime(2020, 3, 1), datetime(2026, 2, 1)),
                (datetime(1970, 1, 1), datetime(1997, 8, 22)),
            ],
            datetime(1970, 1, 1, tzinfo=MO_TZ),
            datetime(2026, 2, 1, tzinfo=MO_TZ),
        ),
        # Multiple engagements, with random times and timezones
        (
            [
                (
                    datetime(
                        2018,
                        12,
                        7,
                        tzinfo=timezone(timedelta(hours=3, minutes=14)),
                    ),
                    datetime(
                        2024,
                        10,
                        12,
                        tzinfo=timezone(timedelta(hours=2, minutes=71)),
                    ),
                ),
                (
                    datetime(1969, 7, 20, 20, 17, 40, tzinfo=UTC),
                    datetime(1972, 12, 19, 19, 54, 58, tzinfo=UTC),
                ),
                (
                    datetime(
                        1970,
                        1,
                        1,
                        tzinfo=timezone(timedelta(hours=-23, minutes=-59)),
                    ),
                    datetime(
                        2100,
                        12,
                        31,
                        23,
                        59,
                        59,
                        tzinfo=timezone(timedelta(hours=23, minutes=59)),
                    ),
                ),
            ],
            datetime(1969, 7, 20, tzinfo=MO_TZ),
            datetime(2100, 12, 31, tzinfo=MO_TZ),
        ),
    ],
)
async def test_get_employment_interval(
    graphql_client: GraphQLClient,
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
    intervals: list[tuple[datetime | None, datetime | None]],
    start: datetime,
    end: datetime,
) -> None:
    # Create engagements for our intervals
    for i, (from_, to) in enumerate(intervals):
        await graphql_client.engagement_create(
            input=EngagementCreateInput(
                user_key="engagement_" + str(i),
                person=mo_person,
                org_unit=mo_org_unit,
                engagement_type=ansat,
                job_function=jurist,
                primary=primary,
                validity={
                    "from": from_.isoformat() if from_ else None,
                    "to": to.isoformat() if to else None,
                },
            )
        )

    result = await get_employment_interval(graphql_client, mo_person)
    assert result == (start, end)


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "CONVERSION_MAPPING": json.dumps(
            {
                "mo2ldap": """
                    {% set starttime, endtime = get_employment_interval(uuid) %}

                    {{
                        {
                            "title": starttime.date().isoformat() if starttime else [],
                            "carLicense": endtime.date().isoformat() if endtime else [],
                        }|tojson
                    }}
                """,
                # TODO: why is this required?
                "username_generator": {
                    "objectClass": "UserNameGenerator",
                    "combinations_to_try": ["FFFX", "LLLX"],
                },
            }
        ),
    }
)
async def test_get_employment_interval_mapping(
    graphql_client: GraphQLClient,
    test_client: AsyncClient,
    ldap_connection: Connection,
    ldap_person: list[str],
    mo_person: UUID,
    mo_org_unit: UUID,
    ansat: UUID,
    jurist: UUID,
    primary: UUID,
) -> None:
    async def trigger_sync() -> None:
        content = str(mo_person)
        headers = {"Content-Type": "text/plain"}
        result = await test_client.post(
            "/mo2ldap/person", content=content, headers=headers
        )
        assert result.status_code == 200

    await graphql_client.engagement_create(
        input=EngagementCreateInput(
            user_key="engagement",
            person=mo_person,
            org_unit=mo_org_unit,
            engagement_type=ansat,
            job_function=jurist,
            primary=primary,
            validity={
                "from": datetime(1969, 7, 20, 20, 17, 40).isoformat(),
                "to": datetime(1972, 12, 19, 19, 54, 58).isoformat(),
            },
        )
    )

    person_dn = combine_dn_strings(ldap_person)

    ldap_object = await get_ldap_object(ldap_connection, person_dn)
    assert ldap_object.dn == person_dn
    assert hasattr(ldap_object, "carLicense") is False

    # Trigger the sync
    await trigger_sync()

    ldap_object = await get_ldap_object(ldap_connection, person_dn)
    assert ldap_object.dn == person_dn
    assert hasattr(ldap_object, "carLicense") is True

    assert getattr(ldap_object, "title", None) == ["1969-07-20"]
    assert getattr(ldap_object, "carLicense", None) == ["1972-12-19"]
