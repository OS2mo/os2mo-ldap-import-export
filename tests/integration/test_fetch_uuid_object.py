# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from uuid import UUID
from uuid import uuid4

import pytest
from fastramqpi.context import Context
from pydantic import parse_obj_as

from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    AddressCreateInput,
)
from mo_ldap_import_export.depends import GraphQLClient
from mo_ldap_import_export.import_export import SyncTool
from mo_ldap_import_export.models import Address
from mo_ldap_import_export.models import Employee
from mo_ldap_import_export.models import Engagement
from mo_ldap_import_export.models import ITUser
from mo_ldap_import_export.models import MOBase
from mo_ldap_import_export.models import Validity
from mo_ldap_import_export.utils import MO_TZ


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
@pytest.mark.parametrize("mo_class", [Address, Engagement, ITUser, Employee])
async def test_fetch_uuid_object_unknown_uuid(
    context: Context, mo_class: type[MOBase]
) -> None:
    sync_tool: SyncTool = context["user_context"]["sync_tool"]

    unknown_uuid = uuid4()
    result = await sync_tool.fetch_uuid_object(unknown_uuid, mo_class)
    assert result is None


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_fetch_uuid_object_bad_class(context: Context) -> None:
    sync_tool: SyncTool = context["user_context"]["sync_tool"]

    unknown_uuid = uuid4()
    with pytest.raises(AssertionError) as exc_info:
        await sync_tool.fetch_uuid_object(unknown_uuid, ValueError)  # type: ignore
    assert "Unknown mo_class: <class 'ValueError'>" in str(exc_info.value)


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_fetch_uuid_object_existing_address(
    context: Context,
    graphql_client: GraphQLClient,
    mo_org_unit: UUID,
    email_unit: UUID,
    public: UUID,
) -> None:
    sync_tool: SyncTool = context["user_context"]["sync_tool"]

    mo_address = await graphql_client.address_create(
        input=AddressCreateInput(
            user_key="test address",
            address_type=email_unit,
            value="test@example.org",
            org_unit=mo_org_unit,
            visibility=public,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )
    result = await sync_tool.fetch_uuid_object(mo_address.uuid, Address)
    assert result == Address(
        uuid=mo_address.uuid,
        user_key=str(mo_address.uuid),
        address_type=email_unit,
        org_unit=mo_org_unit,
        visibility=public,
        value="test@example.org",
        validity=parse_obj_as(
            Validity, {"from": datetime(2001, 2, 3, 0, 0, tzinfo=MO_TZ), "to": None}
        ),
    )
