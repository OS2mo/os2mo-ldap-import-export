# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from asyncio import sleep
from datetime import timedelta
from functools import partial
from unittest.mock import AsyncMock
from uuid import UUID

import pytest
from fastramqpi.context import Context
from more_itertools import one

from mo_ldap_import_export.autogenerated_graphql_client.client import GraphQLClient
from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    ListenerCreateInput,
)
from mo_ldap_import_export.config import Settings
from mo_ldap_import_export.ldap_event_generator import _generate_events
from mo_ldap_import_export.ldap_event_generator import _poll
from mo_ldap_import_export.types import LDAPUUID
from mo_ldap_import_export.utils import combine_dn_strings
from tests.integration.conftest import AddLdapPerson
from tests.integration.conftest import DNList2UUID


@pytest.fixture
def search_base() -> str:
    settings = Settings()
    ldap_ou_to_search_in = one(settings.ldap_ous_to_search_in)
    return combine_dn_strings([ldap_ou_to_search_in, settings.ldap_search_base])


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "LDAP_OUS_TO_SEARCH_IN": '["ou=os2mo,o=magenta"]',
    }
)
@pytest.mark.parametrize(
    "",
    [
        # Integration time is far behind LDAP time
        pytest.param(
            marks=pytest.mark.freeze_time(
                timedelta(days=-1), tick=True, real_asyncio=True
            )
        ),
        # Integration time is very close to LDAP time
        pytest.param(
            marks=pytest.mark.freeze_time(
                timedelta(days=0), tick=True, real_asyncio=True
            )
        ),
        # Integration time is far ahead of LDAP time
        pytest.param(
            marks=pytest.mark.freeze_time(
                timedelta(days=1), tick=True, real_asyncio=True
            )
        ),
    ],
)
@pytest.mark.usefixtures("test_client")
async def test_no_desync(
    context: Context,
    search_base: str,
    ldap_org_unit_uuid: UUID,
    add_ldap_person: AddLdapPerson,
    dnlist2uuid: DNList2UUID,
) -> None:
    dataloader = context["user_context"]["dataloader"]
    sessionmaker = context["sessionmaker"]
    graphql_client: GraphQLClient = context["graphql_client"]

    listener = await graphql_client.declare_event_listener(
        input=ListenerCreateInput(
            namespace="ldap",
            routing_key="uuid",
            user_key="test",
        )
    )

    async def generate_events() -> set[LDAPUUID]:
        await _generate_events(
            graphql_client=graphql_client,
            ldap_amqpsystem=AsyncMock(),
            search_base=search_base,
            sessionmaker=sessionmaker,
            seeded_poller=partial(
                _poll,
                ldap_connection=dataloader.ldapapi.connection,
                search_base=search_base,
                ldap_unique_id_field=Settings().ldap_unique_id_field,
            ),
        )
        uuids = set()
        while (event := await graphql_client.fetch_event(listener.uuid)) is not None:
            await graphql_client.acknowledge_event(event.token)
            uuids.add(LDAPUUID(event.subject))
        return uuids

    # This checks from the start of the universe till now
    # We expect there to be only our ldap org
    results = await generate_events()
    assert results == {ldap_org_unit_uuid}

    # Sleep for one second to to ensure our person is not created in same second as
    # the ldap org. This is required since our timestamps are truncated to suport AD.
    await sleep(1)
    ldap_person_uuid = await dnlist2uuid(await add_ldap_person("abk", "0101901234"))
    assert ldap_person_uuid is not None

    # This checks from 1 second ago till now, we expect "ldap_org_unit_uuid" to appear again,
    # since we are starting at the second it was in (truncating).
    results = await generate_events()
    assert results == {ldap_org_unit_uuid, ldap_person_uuid}

    # We wait another second and check again. We now expect "ldap_org_unit_uuid" to have
    # disappeared, since we are 2 seconds / truncations away, however "ldap_person_uuid"
    # should still appear, since we are within its truncated second.
    await sleep(1)
    results = await generate_events()
    assert results == {ldap_person_uuid}

    # We wait another second and check again. We now expect "ldap_person_uuid" to have
    # disappeared, since we are 2 seconds / truncations away.
    # That ldap_person_uuid disappears is important as we otherwise spam the same event
    # over and over forever.
    await sleep(1)
    results = await generate_events()
    assert results == set()
