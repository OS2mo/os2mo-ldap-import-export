# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
"""Integration tests for the DirSync-based LDAP event generator against Samba AD."""

import ldap3
import pytest
from fastramqpi.context import Context
from more_itertools import one
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.ext.asyncio import async_sessionmaker

from mo_ldap_import_export.autogenerated_graphql_client.client import GraphQLClient
from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    ListenerCreateInput,
)
from mo_ldap_import_export.config import Settings
from mo_ldap_import_export.dirsync_event_generator import DirSyncEventGenerator
from mo_ldap_import_export.dirsync_event_generator import DirSyncState
from mo_ldap_import_export.dirsync_event_generator import configure_dirsync_connection
from mo_ldap_import_export.types import LDAPUUID
from mo_ldap_import_export.utils import combine_dn_strings

from .conftest import SAMBA_ENVVARS


async def add_samba_user(ldap_connection, ldap_org_unit, cn, sam):
    """Create a user in Samba AD and return its DN parts."""
    dn_parts = [f"CN={cn}"] + ldap_org_unit
    await ldap_connection.ldap_add(
        combine_dn_strings(dn_parts),
        object_class=["top", "person", "organizationalPerson", "user"],
        attributes={
            "objectClass": ["top", "person", "organizationalPerson", "user"],
            "cn": cn,
            "sn": cn.split()[-1],
            "sAMAccountName": sam,
            "userPrincipalName": f"{sam}@magenta.dk",
        },
    )
    return dn_parts


async def lookup_uuid(ldap_connection, ldap_org_unit, sam, unique_id_field):
    """Look up the objectGUID of a user by sAMAccountName."""
    response, _ = await ldap_connection.ldap_search(
        search_base=combine_dn_strings(ldap_org_unit),
        search_filter=f"(sAMAccountName={sam})",
        attributes=[unique_id_field],
    )
    return LDAPUUID(one(response)["attributes"][unique_id_field])


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        **SAMBA_ENVVARS,
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "LDAP_OBJECT_CLASS": "user",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_poll(
    context: Context,
    ldap_org_unit: list[str],
) -> None:
    """Test that DirSync poll detects creates, modifies, and idle states.

    Walks through a lifecycle:
    1. Initial poll returns all existing user objects and a cookie
    2. Create user - incremental poll returns exactly that user
    3. Modify a mapped attribute - incremental poll detects the modification
    4. Modify an unmapped attribute - incremental poll ignores it
    5. No changes - incremental poll returns empty set
    """
    settings = Settings()
    ldap_connection = context["user_context"]["dataloader"].ldapapi.ldap_connection
    dirsync_connection = configure_dirsync_connection(settings)

    try:
        event_generator = DirSyncEventGenerator(
            sessionmaker=context["sessionmaker"],
            settings=settings,
            graphql_client=context["graphql_client"],
            dirsync_connection=dirsync_connection,
        )

        # --- Step 1: Initial full sync ----------------------------------------
        initial_uuids, cookie = await event_generator.poll(None)
        assert cookie is not None
        # smblds does not report pre-provisioned accounts in the initial DirSync;
        # the cookie is what matters for subsequent incremental syncs.

        # --- Step 2: Create user ----------------------------------------------
        await add_samba_user(ldap_connection, ldap_org_unit, "Poll Test", "poll_test")
        created_uuid = await lookup_uuid(
            ldap_connection, ldap_org_unit, "poll_test", settings.ldap_unique_id_field
        )

        changed_uuids, cookie = await event_generator.poll(cookie)
        assert changed_uuids == {created_uuid}

        # --- Step 3: Modify mapped attribute (sn) -----------------------------
        user_dn = combine_dn_strings(["CN=Poll Test"] + ldap_org_unit)
        await ldap_connection.ldap_modify(
            user_dn, {"sn": [(ldap3.MODIFY_REPLACE, ["Modified"])]}
        )

        changed_uuids, cookie = await event_generator.poll(cookie)
        assert changed_uuids == {created_uuid}

        # --- Step 4: Modify unmapped attribute (description) ------------------
        # 'description' is not in any ldap_to_mo mapping, so DirSync should
        # not report the change.
        await ldap_connection.ldap_modify(
            user_dn, {"description": [(ldap3.MODIFY_REPLACE, ["irrelevant"])]}
        )

        ignored, cookie = await event_generator.poll(cookie)
        assert ignored == set()

        # --- Step 5: No changes -----------------------------------------------
        no_changes, cookie = await event_generator.poll(cookie)
        assert no_changes == set()
    finally:
        dirsync_connection.unbind()


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        **SAMBA_ENVVARS,
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "LDAP_OBJECT_CLASS": "user",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_poll_attribute_filtering(
    context: Context,
    ldap_org_unit: list[str],
) -> None:
    """Verify that DirSync only emits events for changes to mapped attributes.

    DirSync (MS-ADTS §3.1.1.3.4.6) only reports objects where a *requested*
    attribute changed.  Our generator requests exactly the attributes declared
    in the conversion mapping (plus the unique-id and CPR fields).

    This test asserts that:
    * Changing a **mapped** attribute (``sn``, ``givenName``) produces an event.
    * Changing an **unmapped** attribute (``description``, ``department``,
      ``physicalDeliveryOfficeName``) does **not** produce an event.

    The latter category covers the same DirSync filtering mechanism that
    prevents frequently-changing operational attributes — ``lastLogon``,
    ``logonCount``, ``badPwdCount``, ``pwdLastSet`` etc. — from flooding the
    event pipeline, since those attributes are never included in the request
    set.
    """
    settings = Settings()
    ldap_connection = context["user_context"]["dataloader"].ldapapi.ldap_connection
    dirsync_connection = configure_dirsync_connection(settings)

    try:
        event_generator = DirSyncEventGenerator(
            sessionmaker=context["sessionmaker"],
            settings=settings,
            graphql_client=context["graphql_client"],
            dirsync_connection=dirsync_connection,
        )

        # Initial full sync — consume built-in accounts
        _, cookie = await event_generator.poll(None)

        # Create a test user and consume the creation event
        await add_samba_user(
            ldap_connection, ldap_org_unit, "Filter Test", "filter_test"
        )
        user_uuid = await lookup_uuid(
            ldap_connection,
            ldap_org_unit,
            "filter_test",
            settings.ldap_unique_id_field,
        )
        user_dn = combine_dn_strings(["CN=Filter Test"] + ldap_org_unit)

        changed, cookie = await event_generator.poll(cookie)
        assert changed == {user_uuid}

        # -- Mapped attributes: changes SHOULD produce events ----------------

        # 'sn' is listed in _ldap_attributes_ of the default Employee mapping
        await ldap_connection.ldap_modify(
            user_dn, {"sn": [(ldap3.MODIFY_REPLACE, ["NewSurname"])]}
        )
        changed, cookie = await event_generator.poll(cookie)
        assert changed == {user_uuid}, "Mapped attribute 'sn' must trigger an event"

        # 'givenName' is also in _ldap_attributes_
        await ldap_connection.ldap_modify(
            user_dn, {"givenName": [(ldap3.MODIFY_REPLACE, ["NewGiven"])]}
        )
        changed, cookie = await event_generator.poll(cookie)
        assert changed == {
            user_uuid
        }, "Mapped attribute 'givenName' must trigger an event"

        # -- Unmapped attributes: changes must NOT produce events ------------

        # 'description' is a general-purpose field not in any mapping
        await ldap_connection.ldap_modify(
            user_dn, {"description": [(ldap3.MODIFY_REPLACE, ["Some note"])]}
        )
        changed, cookie = await event_generator.poll(cookie)
        assert (
            changed == set()
        ), "Unmapped attribute 'description' must not trigger an event"

        # 'department' is a common AD attribute that we don't map
        await ldap_connection.ldap_modify(
            user_dn, {"department": [(ldap3.MODIFY_REPLACE, ["Engineering"])]}
        )
        changed, cookie = await event_generator.poll(cookie)
        assert (
            changed == set()
        ), "Unmapped attribute 'department' must not trigger an event"

        # 'physicalDeliveryOfficeName' (office location) is likewise unmapped
        await ldap_connection.ldap_modify(
            user_dn,
            {"physicalDeliveryOfficeName": [(ldap3.MODIFY_REPLACE, ["Room 101"])]},
        )
        changed, cookie = await event_generator.poll(cookie)
        assert (
            changed == set()
        ), "Unmapped attribute 'physicalDeliveryOfficeName' must not trigger an event"

        # -- Sanity: a mapped attribute still works after the unmapped ones --
        await ldap_connection.ldap_modify(
            user_dn, {"sn": [(ldap3.MODIFY_REPLACE, ["FinalSurname"])]}
        )
        changed, cookie = await event_generator.poll(cookie)
        assert changed == {
            user_uuid
        }, "Mapped attribute must still trigger after unmapped changes"
    finally:
        dirsync_connection.unbind()


async def get_dirsync_cookie(
    sessionmaker: async_sessionmaker[AsyncSession],
) -> bytes | None:
    """Return the persisted DirSync cookie, or None if no state row exists."""
    async with sessionmaker() as session, session.begin():
        state = await session.scalar(select(DirSyncState))
        if state is None:
            return None
        return state.cookie


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        **SAMBA_ENVVARS,
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "LDAP_OBJECT_CLASS": "user",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_generate_events(
    context: Context,
    ldap_org_unit: list[str],
) -> None:
    """Test that _generate_events persists state and publishes events correctly.

    Verifies:
    1. Initial call persists a cookie and publishes all existing user UUIDs
    2. After creating a user, only the new user's UUID is published
    3. When no changes have occurred, no events are published
    4. Cookie is always updated in the database
    """
    settings = Settings()
    sessionmaker = context["sessionmaker"]
    graphql_client: GraphQLClient = context["graphql_client"]
    ldap_connection = context["user_context"]["dataloader"].ldapapi.ldap_connection
    dirsync_connection = configure_dirsync_connection(settings)

    try:
        event_generator = DirSyncEventGenerator(
            sessionmaker=sessionmaker,
            settings=settings,
            graphql_client=graphql_client,
            dirsync_connection=dirsync_connection,
        )

        listener = await graphql_client.declare_event_listener(
            input=ListenerCreateInput(
                namespace=settings.event_namespace,
                routing_key="uuid",
                user_key="test_dirsync",
            )
        )

        async def drain_events() -> set[LDAPUUID]:
            uuids = set()
            while (
                event := await graphql_client.fetch_event(listener.uuid)
            ) is not None:
                await graphql_client.acknowledge_event(event.token)
                uuids.add(LDAPUUID(event.subject))
            return uuids

        # --- Step 1: Initial sync persists a cookie ----------------------------
        assert await get_dirsync_cookie(sessionmaker) is None

        await event_generator._generate_events()

        initial_cookie = await get_dirsync_cookie(sessionmaker)
        assert initial_cookie is not None

        initial_events = await drain_events()
        # smblds does not report pre-provisioned accounts in the initial DirSync,
        # so the initial event set may be empty.

        # --- Step 2: Create user - only new user published --------------------
        await add_samba_user(ldap_connection, ldap_org_unit, "Event Test", "event_test")
        created_uuid = await lookup_uuid(
            ldap_connection, ldap_org_unit, "event_test", settings.ldap_unique_id_field
        )

        await event_generator._generate_events()

        post_create_cookie = await get_dirsync_cookie(sessionmaker)
        assert post_create_cookie is not None
        assert post_create_cookie != initial_cookie

        created_events = await drain_events()
        assert created_events == {created_uuid}

        # --- Step 3: No changes - no events published -------------------------
        await event_generator._generate_events()

        no_change_cookie = await get_dirsync_cookie(sessionmaker)
        # Cookie still advances even without changes
        assert no_change_cookie is not None

        no_events = await drain_events()
        assert no_events == set()
    finally:
        dirsync_connection.unbind()
