# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import json
from datetime import datetime
from uuid import UUID

import pytest
from httpx import AsyncClient
from more_itertools import one

from mo_ldap_import_export.autogenerated_graphql_client import GraphQLClient
from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    ITSystemCreateInput,
)
from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    ITUserCreateInput,
)
from mo_ldap_import_export.utils import MO_TZ


@pytest.fixture
async def account_name_itsystem(graphql_client: GraphQLClient) -> UUID:
    account_name = await graphql_client.itsystem_create(
        input=ITSystemCreateInput(
            user_key="account_name",
            name="Account Name",
            validity={"from": "1970-01-01T00:00:00Z"},
        )
    )
    return account_name.uuid


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "LISTEN_TO_CHANGES_IN_MO": "False",
    }
)
async def test_non_existing_account_names_no_at_date(test_client: AsyncClient) -> None:
    response = await test_client.post("/fixup/delete_non_existing_account_names")
    assert response.status_code == 422
    assert response.json() == {
        "detail": [
            {
                "loc": ["query", "at"],
                "msg": "field required",
                "type": "value_error.missing",
            }
        ]
    }


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "CONVERSION_MAPPING": json.dumps(
            {"username_generator": {"existing_usernames_itsystem": "account_name"}}
        ),
    }
)
async def test_non_existing_account_names_no_itsystem(test_client: AsyncClient) -> None:
    response = await test_client.post(
        "/fixup/delete_non_existing_account_names",
        params={"at": datetime(2025, 1, 1).isoformat()},
    )
    assert response.status_code == 404
    assert response.json() == {"detail": "itsystem not found, user_key: account_name"}


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "CONVERSION_MAPPING": json.dumps(
            {"username_generator": {"existing_usernames_itsystem": "account_name"}}
        ),
    }
)
@pytest.mark.usefixtures("account_name_itsystem")
async def test_non_existing_account_names_empty(test_client: AsyncClient) -> None:
    response = await test_client.post(
        "/fixup/delete_non_existing_account_names",
        params={"at": datetime(2025, 1, 1).isoformat()},
    )
    assert response.status_code == 200
    assert response.json() == []


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "CONVERSION_MAPPING": json.dumps(
            {"username_generator": {"existing_usernames_itsystem": "account_name"}}
        ),
    }
)
@pytest.mark.usefixtures("ldap_person")
async def test_non_existing_account_names(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    account_name_itsystem: UUID,
    mo_person: UUID,
) -> None:
    # Our LDAP person has abk as username, so this one should persist
    ituser_start = datetime(1980, 1, 1, tzinfo=MO_TZ)
    abk = await graphql_client.ituser_create(
        input=ITUserCreateInput(
            user_key="abk",
            itsystem=account_name_itsystem,
            person=mo_person,
            validity={"from": ituser_start},
        )
    )
    # While this one should be erased
    cba = await graphql_client.ituser_create(
        input=ITUserCreateInput(
            user_key="cba",
            itsystem=account_name_itsystem,
            person=mo_person,
            validity={"from": ituser_start},
        )
    )

    # Dry-run to see that our IT-user would be collected
    termination_time = datetime(2025, 1, 1, tzinfo=MO_TZ)
    response = await test_client.post(
        "/fixup/delete_non_existing_account_names",
        params={"at": termination_time.isoformat()},
    )
    assert response.status_code == 200
    assert response.json() == [str(cba.uuid)]

    # Actually run to collect it
    response = await test_client.post(
        "/fixup/delete_non_existing_account_names",
        params={"at": termination_time.isoformat(), "dry_run": False},
    )
    assert response.status_code == 200
    assert response.json() == [str(cba.uuid)]

    # Dry-run to see that it was indeed collected
    response = await test_client.post(
        "/fixup/delete_non_existing_account_names",
        params={"at": termination_time.isoformat()},
    )
    assert response.status_code == 200
    assert response.json() == []

    result = await graphql_client.read_itusers(
        uuids=[abk.uuid, cba.uuid], from_date=None, to_date=None
    )
    obj_map = {
        one(obj["validities"])["user_key"]: one(obj["validities"])
        for obj in result.dict()["objects"]
    }
    assert obj_map == {
        "abk": {
            "employee_uuid": mo_person,
            "engagement_uuid": None,
            "itsystem_uuid": account_name_itsystem,
            "user_key": "abk",
            "external_id": None,
            "rolebindings": [],
            "validity": {"from_": ituser_start, "to": None},
        },
        "cba": {
            "employee_uuid": mo_person,
            "engagement_uuid": None,
            "itsystem_uuid": account_name_itsystem,
            "user_key": "cba",
            "external_id": None,
            "rolebindings": [],
            "validity": {"from_": ituser_start, "to": termination_time},
        },
    }
