# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import json
from uuid import UUID

import pytest
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from fastramqpi.events import Event
from fastramqpi.pytest_plugin import run_server
from fastramqpi.pytest_plugin import run_test_client
from fastramqpi.pytest_util import retrying
from more_itertools import one

from mo_ldap_import_export.autogenerated_graphql_client import GraphQLClient
from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    ClassCreateInput,
)
from mo_ldap_import_export.autogenerated_graphql_client.input_types import FacetFilter
from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    ITSystemCreateInput,
)
from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    ITUserCreateInput,
)
from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    RoleBindingCreateInput,
)
from mo_ldap_import_export.ldapapi import LDAPAPI
from mo_ldap_import_export.types import DN
from mo_ldap_import_export.utils import combine_dn_strings
from tests.integration.conftest import DN2UUID
from tests.integration.conftest import AddLdapPerson


async def trigger_sync(identifier: str, uuid: UUID) -> None:
    async with run_test_client() as client:
        result = await client.post(
            f"/mo_to_ldap/{identifier}",
            json=jsonable_encoder(Event(subject=uuid, priority=10)),
        )
        assert result.status_code == 200, result.text


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "True",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "CONVERSION_MAPPING": json.dumps(
            {
                "mo_to_ldap": [
                    {
                        "identifier": "role_to_group",
                        "routing_key": "class",
                        "object_class": "groupOfNames",
                        "template": """
                    {% set group_uuid = skip_if_none(get_class(uuid)).user_key %}
                    {% set dn = uuid_to_dn(group_uuid) %}

                    {% set itsystem_uuid = skip_if_none(get_class(uuid).it_system) %}
                    {% set itsystem_key = get_itsystem(itsystem_uuid).user_key %}

                    {# Only create groups for classes under distributionlist #}
                    {% if itsystem_key != "distributionlists" %}
                        {{ skip_if_none(None) }}
                    {% endif %}

                    {% set person_uuids = role_uuid_to_person_uuids(uuid) %}
                    {% set dns = person_uuids|map('get_person_dn')|list %}

                    {% set exists = dn|dn_exists %}

                    {{
                        {
                            "dn": dn,
                            "create": not exists,
                            "attributes": {"member": dns}
                        }|tojson
                    }}
                    """,
                    },
                ]
            }
        ),
    }
)
async def test_group_user_key_correlation(
    add_ldap_person: AddLdapPerson,
    ldap_api: LDAPAPI,
    dn2uuid: DN2UUID,
    graphql_client: GraphQLClient,
    app: FastAPI,
    mo_person: UUID,
    ldap_person_dn: DN,
    ldap_org_unit: list[str],
) -> None:
    async def get_group_members(group_dn: DN) -> list[DN]:
        ldap_object = await ldap_api.get_object_by_dn(group_dn)
        assert ldap_object.dn == group_dn
        assert hasattr(ldap_object, "member")
        member = ldap_object.member
        assert isinstance(member, list)
        assert all(isinstance(x, DN) for x in member)
        return member

    async def create_group(group_cn: str, members: list[DN]) -> DN:
        object_classes = ["top", "groupOfNames"]
        group_dn_list = ["cn=" + group_cn] + ldap_org_unit
        group_dn = combine_dn_strings(group_dn_list)
        await ldap_api.ldap_connection.ldap_add(
            group_dn,
            object_class=object_classes,
            attributes={
                "objectClass": object_classes,
                "cn": group_cn,
                "member": members,
            },
        )
        return group_dn

    # Create an LDAP person to fulfill the minimum 1 person requirement for groups
    unrelated_person_dn_list = await add_ldap_person("ava", "0101700000")
    unrelated_person_dn = combine_dn_strings(unrelated_person_dn_list)

    # Create the LDAP group for our All in Magenta distributionlist
    group_dn = await create_group("all_in_magenta", [unrelated_person_dn])
    group_uuid = await dn2uuid(group_dn)

    # Check the expected state of the group
    assert await get_group_members(group_dn) == [unrelated_person_dn]

    # Fetch role facet uuid, and construct MO objects
    role_result = await graphql_client.read_facet_uuid(
        filter=FacetFilter(user_keys=["role"])
    )
    role_facet_uuid = one(role_result.objects).uuid

    # Create distribution list itsystem and all-in-magenta role
    distributionlists = await graphql_client.itsystem_create(
        input=ITSystemCreateInput(
            user_key="distributionlists",
            name="Distributionslister",
            validity={"from": "1970-01-01T00:00:00Z"},
        )
    )
    all_in_magenta = await graphql_client.class_create(
        input=ClassCreateInput(
            name="All in Magenta",
            user_key=str(group_uuid),
            facet_uuid=role_facet_uuid,
            it_system_uuid=distributionlists.uuid,
            scope="TEXT",
            validity={"from": "1970-01-01T00:00:00Z"},
        )
    )

    # Create ITUser for our person, and a distributionlist binding
    ituser = await graphql_client.ituser_create(
        input=ITUserCreateInput(
            user_key=str(mo_person),
            itsystem=distributionlists.uuid,
            person=mo_person,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )
    await graphql_client._testing__rolebinding_create(
        input=RoleBindingCreateInput(
            user_key="-",
            ituser=ituser.uuid,
            role=all_in_magenta.uuid,
            validity={"from": "2001-02-03T04:05:06Z"},
        )
    )

    async with run_server(app):
        await trigger_sync("role_to_group", all_in_magenta.uuid)

        # Check the updated state of the group in LDAP
        # i.e. that the person on the group is now ldap_person_dn
        # If this fails it likely means that we could not correlate the group from the role
        async for attempt in retrying():
            with attempt:
                assert await get_group_members(group_dn) == [ldap_person_dn]
