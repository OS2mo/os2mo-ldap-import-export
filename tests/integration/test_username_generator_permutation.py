# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import json
from datetime import datetime
from uuid import UUID
from uuid import uuid4

import pytest
from fastramqpi.context import Context
from hypothesis import HealthCheck
from hypothesis import given
from hypothesis import settings
from hypothesis import strategies as st
from structlog.testing import capture_logs

from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    EmployeeCreateInput,
)
from mo_ldap_import_export.autogenerated_graphql_client.input_types import (
    ITUserCreateInput,
)
from mo_ldap_import_export.depends import GraphQLClient
from mo_ldap_import_export.environments.generate_username import (
    generate_username_permutation,
)
from mo_ldap_import_export.environments.generate_username import (
    generate_username_permutation_func,
)
from mo_ldap_import_export.exceptions import NoObjectsReturnedException
from mo_ldap_import_export.models import Employee
from tests.integration.conftest import AddLdapPerson


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_generate_username_permutation_invalid_user(context: Context) -> None:
    dataloader = context["user_context"]["dataloader"]
    with pytest.raises(NoObjectsReturnedException) as exc_info:
        await generate_username_permutation(dataloader, uuid4())
    assert "Unable to lookup employee" in str(exc_info.value)


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_generate_username_permutation(
    context: Context,
    mo_person: UUID,
) -> None:
    dataloader = context["user_context"]["dataloader"]
    result = await generate_username_permutation(dataloader, mo_person)
    assert result == "abc1"


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.parametrize(
    "taken,expected",
    [
        # Nothing taken, we generate "abc1"
        (set(), "abc1"),
        # "abc1" taken, we generate "abc2"
        ({"abc1"}, "abc2"),
        # "abc2" taken, but "abc1" free, we generate "abc1"
        ({"abc2"}, "abc1"),
        # Both "abc1" and "abc2" taken, we generate "abc3"
        ({"abc1", "abc2"}, "abc3"),
        # "abc1" to "abc9" taken, we generate "abc10"
        ({f"abc{i}" for i in range(10)}, "abc10"),
        # "abc1" to "abc41" taken, we generate "abc100"
        ({f"abc{i}" for i in range(42)}, "abc42"),
        # "abc1" to "abc99" taken, we generate "abc100"
        ({f"abc{i}" for i in range(100)}, "abc100"),
        # Check case insensitivity
        ({"ABC1"}, "abc2"),
        ({"Abc1"}, "abc2"),
        ({"aBc1"}, "abc2"),
        ({"abC1"}, "abc2"),
    ],
)
@pytest.mark.usefixtures("test_client")
async def test_generate_username_permutation_avoids_ldap_taken_names(
    context: Context,
    mo_person: UUID,
    add_ldap_person: AddLdapPerson,
    taken: set[str],
    expected: str,
) -> None:
    # Create an account in LDAP to take away the username
    for userid in taken:
        await add_ldap_person(userid, "0101701234")

    dataloader = context["user_context"]["dataloader"]
    result = await generate_username_permutation(dataloader, mo_person)
    assert result == expected


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.parametrize(
    "given_name,surname",
    [
        ("A", ""),
        ("Io", "Au"),
    ],
)
@pytest.mark.usefixtures("test_client")
async def test_generate_username_permutation_no_available_usernames(
    context: Context, graphql_client: GraphQLClient, given_name: str, surname: str
) -> None:
    r = await graphql_client.person_create(
        input=EmployeeCreateInput(
            given_name=given_name,
            surname=surname,
            cpr_number="2108613133",
        )
    )

    dataloader = context["user_context"]["dataloader"]
    with pytest.raises(ValueError) as exc_info:
        await generate_username_permutation(dataloader, r.uuid)
    fullname = [given_name.lower(), surname.lower()]
    assert f"cannot create username for input {fullname}" in str(exc_info.value)


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "CONVERSION_MAPPING": json.dumps(
            {
                "username_generator": {
                    "forbidden_usernames": ["abc1"],
                }
            }
        ),
    }
)
@pytest.mark.usefixtures("test_client")
async def test_generate_username_permutation_forbidden_usernames(
    context: Context,
    mo_person: UUID,
) -> None:
    # Ensure our override was loaded
    settings = context["user_context"]["settings"]
    username_config = settings.conversion_mapping.username_generator
    assert username_config.forbidden_usernames == ["abc1"]

    dataloader = context["user_context"]["dataloader"]
    result = await generate_username_permutation(dataloader, mo_person)
    assert result == "abc2"


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "CONVERSION_MAPPING": json.dumps(
            {
                "username_generator": {
                    # Setting "disallow_mo_usernames"
                    # disallow_mo_usernames must be configured using the
                    # `existing_username_itsystem` key which points to the user-key of
                    # the IT-system containing the reserved LDAP usernames.
                    # For testing we use the existing ADtitle system.
                    "disallow_mo_usernames": "True",
                    "existing_usernames_itsystem": "ADtitle",
                }
            }
        ),
    }
)
@pytest.mark.parametrize(
    "start,end",
    [
        # Past
        (datetime(1970, 1, 1), datetime(1980, 1, 1)),
        # Current
        (datetime(1990, 1, 1), None),
        # Future
        (datetime(3000, 1, 1), None),
    ],
)
@pytest.mark.parametrize(
    "taken,expected",
    # All of these tests-cases are almost identical to the avoid_ldap_taken_names ones
    # This is purposeful as we wish to check that the two functionalities work the
    # same and the only difference is the source for the illegal names
    [
        # Nothing taken, we generate "abc1"
        (set(), "abc1"),
        # "abc1" taken, we generate "abc2"
        ({"abc1"}, "abc2"),
        # "abc2" taken, but "abc1" free, we generate "abc1"
        ({"abc2"}, "abc1"),
        # Both "abc1" and "abc2" taken, we generate "abc3"
        ({"abc1", "abc2"}, "abc3"),
        # "abc1" to "abc9" taken, we generate "abc10"
        ({f"abc{i}" for i in range(10)}, "abc10"),
        # "abc1" to "abc41" taken, we generate "abc100"
        ({f"abc{i}" for i in range(42)}, "abc42"),
        # "abc1" to "abc99" taken, we generate "abc100"
        ({f"abc{i}" for i in range(100)}, "abc100"),
        # Check case insensitivity
        # NOTE: MO does not support insensitivity
        ({"ABC1"}, "abc1"),
        ({"Abc1"}, "abc1"),
        ({"aBc1"}, "abc1"),
        ({"abC1"}, "abc1"),
    ],
)
@pytest.mark.usefixtures("test_client")
async def test_generate_username_permutation_avoids_mo_taken_names(
    graphql_client: GraphQLClient,
    context: Context,
    start: datetime,
    end: datetime | None,
    mo_person: UUID,
    adtitle: UUID,
    taken: set[str],
    expected: str,
) -> None:
    # Create an IT-user MO to take away the username
    for userid in taken:
        await graphql_client.ituser_create(
            ITUserCreateInput(
                person=mo_person,
                user_key=userid,
                itsystem=adtitle,
                validity={"from": start, "to": end},
            )
        )

    dataloader = context["user_context"]["dataloader"]
    result = await generate_username_permutation(dataloader, mo_person)
    assert result == expected


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.parametrize(
    "expected",
    [
        # Nothing forbidden yields undesirable username
        pytest.param(
            "abc1",
        ),
        # Forbidden username forces next combination
        pytest.param(
            "abc2",
            marks=pytest.mark.envvar(
                {
                    "CONVERSION_MAPPING": json.dumps(
                        {
                            "username_generator": {
                                "forbidden_usernames": ["abc1"],
                            }
                        }
                    )
                }
            ),
        ),
        pytest.param(
            "abc3",
            marks=pytest.mark.envvar(
                {
                    "CONVERSION_MAPPING": json.dumps(
                        {
                            "username_generator": {
                                "forbidden_usernames": ["abc1", "abc2"],
                            }
                        }
                    )
                }
            ),
        ),
    ],
)
@pytest.mark.usefixtures("test_client")
async def test_generate_username_permutation_with_forbidden_usernames(
    mo_person: UUID,
    context: Context,
    expected: str,
) -> None:
    dataloader = context["user_context"]["dataloader"]
    result = await generate_username_permutation(dataloader, mo_person)
    assert result == expected


@pytest.mark.integration_test
@pytest.mark.parametrize(
    "names,expected",
    [
        ("Abel Spendabel", "asp1"),  # First name starts with a vowel
        ("Erik Ejegod", "ejg1"),  # Both first name and last name start with a vowel
        ("Erik Episk Ejegod", "eps1"),  # All parts start with a vowel
        ("Gorm Den Gamle", "gdn1"),  # All parts start with a consonant
        ("Ba Ca Da", "bcd1"),  # All parts start with a consonant
        ("Theodor Fælgen", "tfl1"),  # Last name contains non-ASCII character
        ("Øjvind Ørn", "jrn1"),  # All parts begin with non-ASCII characters
        ("Ea Obe", "ebb1"),  # Last name contains just one consonant
        ("Ivan Aaaa", "ivn1"),  # Last name contains *only* vocals
        ("Ab Aaa", "abb1"),  # Only *one* consonant across *all* name parts
    ],
)
@pytest.mark.usefixtures("test_client")
async def test_generate_username_permutation_expected_usernames(
    graphql_client: GraphQLClient,
    context: Context,
    names: str,
    expected: str,
) -> None:
    *given_names, surname = names.split(" ")
    mo_person = await graphql_client.person_create(
        input=EmployeeCreateInput(
            given_name=" ".join(given_names), surname=surname, cpr_number="0101700000"
        )
    )

    dataloader = context["user_context"]["dataloader"]
    result = await generate_username_permutation(dataloader, mo_person.uuid)
    assert result == expected


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
    }
)
@pytest.mark.usefixtures("test_client")
async def test_generate_username_permutation_logging(
    context: Context,
    mo_person: UUID,
    add_ldap_person: AddLdapPerson,
) -> None:
    # abc1 is the username we would have generated
    await add_ldap_person("abc1", "0101700000")

    dataloader = context["user_context"]["dataloader"]
    with capture_logs() as cap_logs:
        result = await generate_username_permutation(dataloader, mo_person)
        assert result == "abc2"

    events = [w["event"] for w in cap_logs]
    assert events == [
        "Found forbidden usernames",
        # Generate abc1
        "Rejecting username candidate due to existing LDAP usage",
        # Generate abc2
        "Not configured to check for disallowed MO usernames",
        "Generated username based on name",
    ]


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "LISTEN_TO_CHANGES_IN_MO": "False",
        "LISTEN_TO_CHANGES_IN_LDAP": "False",
        "CONVERSION_MAPPING": json.dumps(
            {
                "username_generator": {
                    "disallow_mo_usernames": "True",
                    "existing_usernames_itsystem": "ADtitle",
                    "reuse_old_usernames": "True",
                }
            }
        ),
    }
)
@pytest.mark.parametrize(
    "own_reserve,other_reserve,expected",
    [
        (False, False, "abc1"),
        (True, False, "abc1"),
        (False, True, "abc2"),
        (True, True, "abc2"),
    ],
)
@pytest.mark.usefixtures("test_client")
async def test_generate_username_permutation_reuses_mo_usernames(
    graphql_client: GraphQLClient,
    context: Context,
    adtitle: UUID,
    mo_person: UUID,
    own_reserve: bool,
    other_reserve: bool,
    expected: str,
) -> None:
    reserve_uuids = set()
    if own_reserve:
        reserve_uuids.add(mo_person)
    if other_reserve:
        other_mo_person = await graphql_client.person_create(
            input=EmployeeCreateInput(
                cpr_number="0101700000", given_name="Other", surname="Person"
            )
        )
        reserve_uuids.add(other_mo_person.uuid)

    for person_uuid in reserve_uuids:
        await graphql_client.ituser_create(
            ITUserCreateInput(
                person=person_uuid,
                user_key="abc1",
                itsystem=adtitle,
                validity={"from": datetime(1970, 1, 1), "to": None},
            )
        )

    dataloader = context["user_context"]["dataloader"]
    result = await generate_username_permutation(dataloader, mo_person)
    assert result == expected


@pytest.mark.integration_test
@given(
    st.lists(
        st.text(
            min_size=1,
            alphabet=st.characters(
                whitelist_characters="bcdfghjklmnpqrstvwxz",
                whitelist_categories=(),
            ),
        ),
        min_size=2,
    )
)
@pytest.mark.usefixtures("minimal_valid_environmental_variables")
@settings(suppress_health_check=[HealthCheck.function_scoped_fixture])
async def test_valid_input(context: Context, name: list[str]) -> None:
    # If `name` has at least two items, each item being a string of at least
    # one consonant, we should be able to create a username.
    employee = Employee(
        given_name=name[0],
        surname=" ".join(name[1:]),
    )

    dataloader = context["user_context"]["dataloader"]
    # This calls the underlying function directly to avoid reusing CPR number
    await generate_username_permutation_func(
        dataloader.settings, dataloader.ldapapi.connection, dataloader.moapi, employee
    )
