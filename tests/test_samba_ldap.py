# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import json
from datetime import UTC
from datetime import datetime
from typing import cast

import pytest
from ldap3 import ALL
from ldap3 import Connection
from ldap3 import Server
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.ext.asyncio import async_sessionmaker

from mo_ldap_import_export.autogenerated_graphql_client import GraphQLClient
from mo_ldap_import_export.config import Settings
from mo_ldap_import_export.ldap import configure_ldap_connection
from mo_ldap_import_export.ldap_event_generator import LDAPEventGenerator

SAMBA_HOST = "localhost"
SAMBA_PORT = 3890
SAMBA_ADMIN_DN = "cn=admin,dc=samba,dc=local"
SAMBA_ADMIN_PASSWORD = "adminpassword"
SAMBA_BASE_DN = "dc=samba,dc=local"


@pytest.fixture
def ldap_connection():
    """Create a simple connection to the Samba LDAP server for test data setup."""
    server = Server(SAMBA_HOST, port=SAMBA_PORT, get_info=ALL)
    conn = Connection(server, user=SAMBA_ADMIN_DN, password=SAMBA_ADMIN_PASSWORD)
    bound = conn.bind()
    assert bound, f"Failed to bind to LDAP server: {conn.last_error}"
    yield conn
    conn.unbind()


@pytest.fixture
def users_ou(ldap_connection):
    """Create an organizational unit for users."""
    ou_dn = f"ou=users,{SAMBA_BASE_DN}"
    ldap_connection.add(
        ou_dn,
        object_class=["top", "organizationalUnit"],
        attributes={"ou": "users"},
    )
    yield ou_dn
    ldap_connection.delete(ou_dn)


def test_samba_ldap_create_and_read_persons(ldap_connection, users_ou):
    """Test creating persons in Samba LDAP and reading them back."""
    persons = [
        {
            "uid": "jdoe",
            "cn": "John Doe",
            "sn": "Doe",
            "givenName": "John",
            "mail": "john.doe@example.com",
        },
        {
            "uid": "asmith",
            "cn": "Alice Smith",
            "sn": "Smith",
            "givenName": "Alice",
            "mail": "alice.smith@example.com",
        },
    ]

    created_dns = []
    try:
        for person in persons:
            person_dn = f"uid={person['uid']},{users_ou}"
            result = ldap_connection.add(
                person_dn,
                object_class=["top", "person", "organizationalPerson", "inetOrgPerson"],
                attributes=person,
            )
            assert result, f"Failed to create {person['uid']}: {ldap_connection.result}"
            created_dns.append(person_dn)

        for person in persons:
            ldap_connection.search(
                search_base=users_ou,
                search_filter=f"(uid={person['uid']})",
                attributes=["uid", "cn", "sn", "givenName", "mail"],
            )
            assert len(ldap_connection.entries) == 1, (
                f"Expected 1 entry for {person['uid']}, got {len(ldap_connection.entries)}"
            )

            entry = ldap_connection.entries[0]
            assert str(entry.uid) == person["uid"]
            assert str(entry.cn) == person["cn"]
            assert str(entry.sn) == person["sn"]
            assert str(entry.givenName) == person["givenName"]
            assert str(entry.mail) == person["mail"]

    finally:
        for dn in created_dns:
            ldap_connection.delete(dn)


@pytest.fixture
def samba_settings(monkeypatch):
    """Create Settings configured for the Samba LDAP server."""
    monkeypatch.setenv("CLIENT_ID", "test")
    monkeypatch.setenv("CLIENT_SECRET", "test")
    monkeypatch.setenv("LDAP_CONTROLLERS", json.dumps([{"host": SAMBA_HOST, "port": SAMBA_PORT}]))
    monkeypatch.setenv("LDAP_DOMAIN", "samba.local")
    monkeypatch.setenv("LDAP_USER", SAMBA_ADMIN_DN)
    monkeypatch.setenv("LDAP_PASSWORD", SAMBA_ADMIN_PASSWORD)
    monkeypatch.setenv("LDAP_SEARCH_BASE", SAMBA_BASE_DN)
    monkeypatch.setenv("LDAP_OUS_TO_SEARCH_IN", json.dumps(["ou=users"]))
    monkeypatch.setenv("LDAP_OBJECT_CLASS", "inetOrgPerson")
    monkeypatch.setenv("LDAP_CPR_ATTRIBUTE", "employeeNumber")
    monkeypatch.setenv("LDAP_DIALECT", "Standard")
    monkeypatch.setenv("LDAP_AUTH_METHOD", "simple")
    monkeypatch.setenv("FASTRAMQPI__DATABASE__USER", "fastramqpi")
    monkeypatch.setenv("FASTRAMQPI__DATABASE__PASSWORD", "fastramqpi")
    monkeypatch.setenv("FASTRAMQPI__DATABASE__HOST", "localhost")
    monkeypatch.setenv("FASTRAMQPI__DATABASE__NAME", "fastramqpi")
    monkeypatch.setenv(
        "CONVERSION_MAPPING",
        json.dumps({
            "ldap_to_mo": {
                "Employee": {
                    "objectClass": "Employee",
                    "_import_to_mo_": "false",
                    "_ldap_attributes_": [],
                    "uuid": "{{ employee_uuid or '' }}",
                }
            },
        }),
    )
    return Settings()


@pytest.fixture
def samba_ldap_connection(samba_settings):
    """Create an LDAP connection configured for LDAPEventGenerator."""
    conn = configure_ldap_connection(samba_settings)
    yield conn
    conn.unbind()


@pytest.fixture
def ldap_event_generator(samba_ldap_connection, samba_settings):
    """Create an LDAPEventGenerator for the Samba LDAP server.

    Note: sessionmaker and graphql_client are not used by poll(),
    so we pass placeholder values cast to the expected types.
    """
    generator = LDAPEventGenerator(
        sessionmaker=cast(async_sessionmaker[AsyncSession], None),
        settings=samba_settings,
        graphql_client=cast(GraphQLClient, None),
        ldap_connection=samba_ldap_connection,
    )
    return generator


async def test_ldap_event_generator_detects_changes(
    ldap_connection, users_ou, ldap_event_generator, samba_settings
):
    """Test that LDAPEventGenerator can detect changes made in Samba."""
    search_base = f"ou=users,{SAMBA_BASE_DN}"

    past_time = datetime(2000, 1, 1, tzinfo=UTC)
    uuids_before, _ = await ldap_event_generator.poll(search_base, past_time)
    assert len(uuids_before) == 0

    person_dn = f"uid=testuser,{users_ou}"
    ldap_connection.add(
        person_dn,
        object_class=["top", "person", "organizationalPerson", "inetOrgPerson"],
        attributes={
            "uid": "testuser",
            "cn": "Test User",
            "sn": "User",
            "givenName": "Test",
            "mail": "test.user@example.com",
        },
    )

    try:
        uuids_after, timestamp = await ldap_event_generator.poll(search_base, past_time)
        assert len(uuids_after) == 1
        assert timestamp is not None

        ldap_connection.search(
            search_base=users_ou,
            search_filter="(uid=testuser)",
            attributes=[samba_settings.ldap_unique_id_field],
        )
        entry = ldap_connection.entries[0]
        expected_uuid = str(entry[samba_settings.ldap_unique_id_field].value)

        detected_uuid = str(list(uuids_after)[0])
        assert detected_uuid == expected_uuid
    finally:
        ldap_connection.delete(person_dn)
