# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import re
from collections.abc import Iterator
from contextlib import suppress
from itertools import groupby
from typing import Any

import structlog
from ldap3 import Connection
from more_itertools import ilen
from more_itertools import one

from .autogenerated_graphql_client.input_types import ITSystemFilter
from .autogenerated_graphql_client.input_types import ITUserFilter
from .config import Settings
from .ldap import paged_search
from .moapi import MOAPI
from .models import Employee
from .utils import combine_dn_strings
from .utils import remove_vowels

logger = structlog.stdlib.get_logger()


def _create_from_combi(name_parts: list[str], combi: str) -> str | None:
    """Create a username from a name and a combination.

    Args:
        name_parts: An array of names; given_name, middlenames, surname.
        combi: Combination to create a username from. For example "F123LX".

    Raises:
        AssertionError: If an invalid character is provided as combi.

    Returns:
        A username generated according to the combination.
        Note that this username may still contain 'X' characters, which need
        to be replaced with a number.
    """

    def char2namepart(combi_char: str) -> str:
        """Convert combi character to corresponding name part.

        Args:
            combi_char: The character to lookup (One of "F", "L", [1-9])

        Raises:
            ValueError: If the captured name_parts has less than 2 entries.
            IndexError: If an integer higher than the number of middlenames is used.
            AssertionError: If an invalid character is provided as combi_char.

        Returns:
            The name part corresponding to the combi character.
        """
        assert combi_char in {"F", "L"} | {str(x) for x in range(1, 10)}

        given_name, *middlenames, surname = name_parts
        match combi_char:
            case "F":
                return given_name
            case "L":
                return surname
            case x:
                index = int(x) - 1
                return middlenames[index]

    def group2string(combi_char: str, count: int) -> str:
        """Construct a username substring from a group (combi_char + count).

        Args:
            combi_char: The character to lookup (One of "X", "F", "L", [1-9])
            count: The number of characters to extract from the combi_char source.

        Raises:
            ValueError: If a referenced name_part does not have enough characters.
            ValueError: If the captured name_parts has less than 2 entries.
            IndexError: If an integer higher than the number of middlenames is used.
            AssertionError: If an invalid character is provided as combi_char.

        Returns:
            The constructed username substring.
        """
        if combi_char == "X":
            return "X" * count
        name_part = char2namepart(combi_char).lower()
        # Sanity check that the name is long enough
        # Without this check we risk making too short usernames
        if count > len(name_part):
            raise ValueError("Name part too short")
        return name_part[:count]

    # Split code into groups on changes
    # For example "FF1LL" returns [("F",2), ("1",1), ("L",2)]
    groups = [(key, ilen(group)) for key, group in groupby(combi)]

    with suppress(IndexError, ValueError):
        username_parts = [group2string(char, count) for (char, count) in groups]
        return "".join(username_parts)
    return None


class UserNameGenerator:
    """
    Class with functions to generate valid LDAP usernames.

    Each customer could have his own username generator function in here. All you need
    to do, is refer to the proper function inside the json dict.
    """

    def __init__(
        self, settings: Settings, moapi: MOAPI, ldap_connection: Connection
    ) -> None:
        self.settings = settings
        username_generator_settings = settings.conversion_mapping.username_generator

        self.moapi = moapi
        self.ldap_connection = ldap_connection

        self.remove_vowels = username_generator_settings.remove_vowels
        self.disallow_mo_usernames = username_generator_settings.disallow_mo_usernames
        self.char_replacement = username_generator_settings.char_replacement
        self.forbidden_usernames = username_generator_settings.forbidden_usernames
        self.combinations = username_generator_settings.combinations_to_try
        logger.info("Found forbidden usernames", count=len(self.forbidden_usernames))

    async def get_existing_values(self, attributes: list[str]) -> dict[str, set[Any]]:
        searchParameters = {
            "search_filter": "(objectclass=*)",
            "attributes": attributes,
        }
        search_base = self.settings.ldap_search_base
        search_result = await paged_search(
            self.settings,
            self.ldap_connection,
            searchParameters,
            search_base,
        )

        output = {}
        for attribute in attributes:
            values = set()
            for entry in search_result:
                value = entry["attributes"][attribute]
                if not value:
                    continue
                if isinstance(value, list):
                    value = one(value)
                values.add(value.lower())
            output[attribute] = values
        return output

    def _make_cn(self, username_string: str):
        return f"CN={username_string}"

    def _make_dn(self, username_string: str) -> str:
        cn = self._make_cn(username_string)
        dn = combine_dn_strings(
            [
                cn,
                self.settings.ldap_ou_for_new_users,
                self.settings.ldap_search_base,
            ]
        )

        return dn

    def _name_fixer(self, name_parts: list[str]) -> list[str]:
        """Cleanup a structured name to remove non-ascii characters.

        Context:
            self.char_replacement:
                Dictionary from one set of characters to their replacements.

        Args:
            name_parts: An array of names; given_name, middlenames, surname.

        Returns:
            `name_parts` where non-ascii characters have been replaced
            according to the char_replacement map, or if unmatched, removed.
        """

        def fix_name(name: str) -> str:
            # Replace according to replacement list
            for char, replacement in self.char_replacement.items():
                name = name.replace(char, replacement)
            # Remove all remaining characters outside a-z
            return re.sub(r"[^a-z]+", "", name.lower())

        def eliminate_vowels_from_surnames(name_parts: list[str]) -> list[str]:
            # Remove vowels from all but first name
            # Reference: https://redmine.magenta-aps.dk/issues/56080
            first_name, *lastnames = name_parts
            return [first_name] + [remove_vowels(n) for n in lastnames]

        name_parts = [fix_name(x) for x in name_parts]
        if self.remove_vowels:
            name_parts = eliminate_vowels_from_surnames(name_parts)
        return name_parts

    async def _create_username(
        self, name: list[str], existing_usernames: set[str]
    ) -> str:
        """
        Create a new username in accordance with the rules specified in the json file.
        The username will be the highest quality available and the value will be
        added to list of used names, so consequtive calles with the same name
        will keep returning new names until the algorithm runs out of options
        and a RuntimeException is raised.

        :param name: Name of the user given as a list with at least two elements.
        :return: New username generated.

        Inspired by ad_integration/usernames.py
        """

        def permutations(username: str) -> Iterator[str]:
            # The permutation is a number inside the username, it is normally only used in
            # case a username is already occupied. It can be specified using 'X' in the
            # username template.
            #
            # The first attempted permutation should be '2':
            # For example; If 'cvt' is occupied, a username 'cvt2' will be generated.
            #
            # The last attempted permutation is '9' - because we would like to limit the
            # permutation counter to a single digit.
            for permutation_counter in range(2, 10):
                yield username.replace("X", str(permutation_counter))

        def forbidden(username: str) -> bool:
            # Check if core username is legal
            return username.replace("X", "") in self.forbidden_usernames

        def existing(username: str) -> bool:
            return username in existing_usernames

        # Cleanup names
        name = self._name_fixer(name)
        # Generate usernames from names and combinations
        usernames = (_create_from_combi(name, combi) for combi in self.combinations)
        for username in usernames:
            if username is None:
                continue
            if forbidden(username):
                continue
            p_usernames = permutations(username)
            for p_username in p_usernames:
                if existing(p_username):
                    continue
                if not await self._mo_allows_username(p_username):
                    logger.debug(
                        "Rejecting username candidate due to disallowed MO usernames",
                        username=p_username,
                    )
                    continue

                return p_username

        # TODO: Return a more specific exception type
        raise RuntimeError("Failed to create user name.")

    def _create_common_name(
        self, name: list[str], existing_common_names: set[str]
    ) -> str:
        """
        Create an LDAP-style common name (CN) based on first and last name

        If a name exists, "_2" is added. If that one also exists, "_3" is added,
        and so on

        Examples
        -------------
        >>> _create_common_name(["Keanu","Reeves"])
        >>> "Keanu Reeves"
        """

        def permutations(username: str) -> Iterator[str]:
            yield username
            for permutation_counter in range(2, 1000):
                yield username + "_" + str(permutation_counter)

        def existing(potential_name: str) -> bool:
            return potential_name.lower() in existing_common_names

        name = [n for n in name if n]
        num_middlenames = len(name) - 2

        # Shorten a name if it is over 64 chars
        # see http://msdn.microsoft.com/en-us/library/ms675449(VS.85).aspx
        common_name = " ".join(name)
        while len(common_name) > 60 and num_middlenames > 0:
            # Remove one middlename
            num_middlenames -= 1
            # Try to make a name with the selected number of middlenames
            given_name, *middlenames, surname = name
            middlenames = middlenames[:num_middlenames]
            common_name = " ".join([given_name] + middlenames + [surname])

        # Cut off the name (leave place for the permutation counter)
        common_name = common_name[:60]

        for potential_name in permutations(common_name):
            if existing(potential_name):
                continue
            return potential_name

        # TODO: Return a more specific exception type
        raise RuntimeError("Failed to create common name")

    async def _get_existing_common_names(self) -> set[str]:
        # TODO: Consider if it is better to fetch all names or candidate names
        existing_values = await self.get_existing_values(["cn"])
        existing_common_names = existing_values["cn"]
        return existing_common_names

    async def _get_existing_ldap_usernames(self) -> set[str]:
        match self.settings.ldap_dialect:
            case "Standard":
                # "uid" is the default login field since RFC2798 (inetOrgPerson)
                # (replacing the "userid" term from RFC1274 (COSINE schema))
                # It is the standard LDAP login name field.
                # The Microsoft Active Directory equivalent is sAMAccountName
                login_fields = ["uid"]
            case "AD":  # pragma: no cover
                login_fields = ["sAMAccountName", "userPrincipalName"]
            case _:  # pragma: no cover
                raise AssertionError("Unknown LDAP dialect")

        # TODO: Consider if it is better to fetch all names or candidate names
        existing_values = await self.get_existing_values(login_fields)

        match self.settings.ldap_dialect:
            case "Standard":
                existing_usernames = existing_values["uid"]
            case "AD":  # pragma: no cover
                user_principal_names = {
                    s.split("@")[0] for s in existing_values["userPrincipalName"]
                }
                existing_usernames = (
                    existing_values["sAMAccountName"] | user_principal_names
                )
            case _:  # pragma: no cover
                raise AssertionError("Unknown LDAP dialect")

        return existing_usernames

    async def _mo_allows_username(self, username: str) -> bool:
        # Check if MO allows the username to be used

        # If we are not limiting by mo usernames, the answer is yes, mo allows all
        if not self.disallow_mo_usernames:
            logger.debug("Not configured to check for disallowed MO usernames")
            return True

        # Otherwise, we gotta check if the username is already taken in MO
        #
        # We have to check both past, present and future usernames to ensure no reuse
        # of usernames is ever done. This works as we never actually delete usernames
        # from MO's database, but rather just terminate by putting end-dates on them.
        #
        # We need to block these usernames from being generated, because it is possible
        # that MO generates a user, which is deleted from AD some years later. In that
        # case we should never generate the username of the deleted user.
        # Reference: https://redmine.magenta-aps.dk/issues/57043

        itsystem_user_key = self.settings.conversion_mapping.username_generator.existing_usernames_itsystem

        # The username is taken iff there exists atleast one validity in MO where:
        # * The username is set in the user-key
        # * The it-system is our usernames it-system
        result = await self.moapi.graphql_client.read_filtered_itusers(
            filter=ITUserFilter(
                itsystem=ITSystemFilter(user_keys=[itsystem_user_key]),
                # NOTE: We actually could check a list of candidate usernames here easily
                user_keys=[username],
                # We check all validities; past, present and future
                from_date=None,
                to_date=None,
            )
        )
        logger.debug("Checked for disallowed MO usernames", result=result)
        # If there are any objects in our result, we must have found atleast one match,
        # which means the username is already taken, hence we cannot allow it.
        return not result.objects

    async def _get_existing_usernames(self) -> set[str]:
        return await self._get_existing_ldap_usernames()

    def generate_person_name(self, employee: Employee) -> list[str]:
        assert employee.given_name is not None
        assert employee.surname is not None
        given_name = employee.given_name
        surname = employee.surname
        name = given_name.split(" ")[:4] + [surname]
        return name

    async def generate_common_name(
        self, employee: Employee, current_common_name: str | None = None
    ) -> str:
        name = self.generate_person_name(employee)
        existing_common_names = await self._get_existing_common_names()
        # We have to discard the current common name, as we may otherwise generate a new
        # common name due to a conflict with ourselves.
        if current_common_name:
            existing_common_names.discard(current_common_name.lower())
        common_name = self._create_common_name(name, existing_common_names)
        logger.info(
            "Generated CommonName based on name",
            name=name,
            common_name=common_name,
        )
        return common_name

    async def generate_username(self, employee: Employee) -> str:
        existing_usernames = await self._get_existing_usernames()
        name = self.generate_person_name(employee)
        username = await self._create_username(name, existing_usernames)
        logger.info("Generated username based on name", name=name, username=username)
        return username

    async def generate_dn(self, employee: Employee) -> str:
        """
        Generates a LDAP DN (Distinguished Name) based on information from a MO Employee
        object.
        """
        common_name = await self.generate_common_name(employee)
        dn = self._make_dn(common_name)
        return dn
