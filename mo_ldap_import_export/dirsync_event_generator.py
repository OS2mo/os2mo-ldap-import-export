# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
"""LDAP change event generation using Microsoft DirSync control.

DirSync (LDAP_SERVER_DIRSYNC_OID 1.2.840.113556.1.4.841) is an Active
Directory specific control for incremental synchronization.  Unlike the
modifyTimestamp-based approach in ``LDAPEventGenerator``, DirSync uses an
opaque server-side cookie that guarantees reliable change detection even across
domain-controller failovers and replication delays.

Constraints imposed by the DirSync protocol:
* The search base MUST be a naming context (root DN), not an arbitrary subtree.
* The connection MUST be a plain synchronous connection – ``SAFE_RESTARTABLE``
  is incompatible because reconnecting invalidates the cookie.
* The caller MUST have the "Replicate Directory Changes" privilege (granted to
  Domain Admins by default).
"""

import asyncio
import base64
from contextlib import AbstractAsyncContextManager
from contextlib import suppress
from typing import Any
from typing import Self

import ldap3
import structlog
from fastramqpi.context import Context
from more_itertools import one
from sqlalchemy import LargeBinary
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.ext.asyncio import async_sessionmaker
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column

from .autogenerated_graphql_client.client import GraphQLClient
from .config import AuthBackendEnum
from .config import Settings
from .database import Base
from .ldap import construct_server
from .ldap_emit import publish_uuids
from .types import LDAPUUID

logger = structlog.stdlib.get_logger()


class DirSyncState(Base):
    """Singleton row storing the DirSync cookie.

    DirSync always operates on the entire naming context, so there is exactly
    one cookie per domain — no need to key by search base.
    """

    __tablename__ = "dirsync_state"

    id: Mapped[int] = mapped_column(primary_key=True)
    cookie: Mapped[bytes | None] = mapped_column(
        LargeBinary, default=None, nullable=True
    )


def configure_dirsync_connection(settings: Settings) -> ldap3.Connection:
    """Configure an LDAP connection suitable for DirSync operations.

    DirSync requires a plain synchronous connection (not SAFE_RESTARTABLE)
    as the cookie state is tied to a specific connection.
    """
    server_config = one(settings.ldap_controllers)
    server = construct_server(server_config)

    connection_kwargs: dict[str, Any] = {
        "server": server,
        "password": settings.ldap_password.get_secret_value(),
        "auto_bind": True,
        "raise_exceptions": True,
    }

    match settings.ldap_auth_method:
        case AuthBackendEnum.NTLM:
            connection_kwargs.update(
                {
                    "user": settings.ldap_domain + "\\" + settings.ldap_user,
                    "authentication": ldap3.NTLM,
                }
            )
        case AuthBackendEnum.SIMPLE:
            connection_kwargs.update(
                {
                    "user": settings.ldap_user,
                    "authentication": ldap3.SIMPLE,
                }
            )
        case _:
            raise ValueError("Unknown authentication backend")

    return ldap3.Connection(**connection_kwargs)


class DirSyncEventGenerator(AbstractAsyncContextManager):
    def __init__(
        self,
        sessionmaker: async_sessionmaker[AsyncSession],
        settings: Settings,
        graphql_client: GraphQLClient,
        dirsync_connection: ldap3.Connection,
    ) -> None:
        """Periodically poll LDAP for changes using Microsoft DirSync control."""
        self.sessionmaker = sessionmaker
        self.settings = settings
        self.graphql_client = graphql_client
        self.dirsync_connection = dirsync_connection

        self._poller: asyncio.Task | None = None

    async def __aenter__(self) -> Self:
        """Start event generator."""
        self._poller = self._setup_poller()
        return self

    async def __aexit__(
        self, __exc_type: object, __exc_value: object, __traceback: object
    ) -> None:
        """Stop event generator."""
        if self._poller is not None:
            self._poller.cancel()
            with suppress(asyncio.CancelledError):
                await self._poller

    async def healthcheck(self, context: dict | Context) -> bool:
        return self._poller is not None and not self._poller.done()

    def encode_poll_state(self, state: Any) -> str:
        if state is None:
            return ""
        return base64.b64encode(state).decode()

    def decode_poll_state(self, token: str | None) -> Any:
        if not token:
            return None
        return base64.b64decode(token)

    def _setup_poller(self) -> asyncio.Task:
        def done_callback(future):
            # Silence CancelledErrors on shutdown
            with suppress(asyncio.CancelledError):
                # This ensures exceptions go to the terminal
                future.result()

        handle = asyncio.create_task(self._poller_loop())
        handle.add_done_callback(done_callback)
        return handle

    async def poll(
        self,
        state: Any,
    ) -> tuple[set[LDAPUUID], Any]:
        """Poll the LDAP server for changes using DirSync control.

        Args:
            state:
                Opaque poll state — a DirSync cookie (``bytes``) or ``None``
                for initial sync.

        Returns:
            Tuple of (set of changed UUIDs, new opaque state).
        """
        cookie: bytes | None = state
        search_base = self.settings.ldap_search_base
        logger.debug(
            "Searching for DirSync changes",
            search_base=search_base,
            has_cookie=cookie is not None,
        )

        # To improve performance and reduce noise, we only listen for changes to
        # objects with object classes that we are configured to consume.
        relevant_object_classes = {
            self.settings.ldap_object_class,
            *self.settings.conversion_mapping.ldap_to_mo_any,
        }
        object_class_filter = "".join(
            f"(objectClass={cls})" for cls in relevant_object_classes
        )
        sync_filter = f"(|{object_class_filter})"

        unique_id_field = self.settings.ldap_unique_id_field
        conn = self.dirsync_connection

        # DirSync only reports objects where a *requested* attribute changed
        # (per MS-ADTS).  Mirror the attribute set from ldap_amqp.py so we
        # detect exactly the changes we care about.
        relevant_attributes = {unique_id_field}
        if self.settings.ldap_cpr_attribute:
            relevant_attributes.add(self.settings.ldap_cpr_attribute)
        if self.settings.discriminator_fields:
            relevant_attributes.update(self.settings.discriminator_fields)
        if self.settings.conversion_mapping.ldap_to_mo:
            for mapping in self.settings.conversion_mapping.ldap_to_mo.values():
                relevant_attributes.update(mapping.ldap_attributes)
        for mappings in self.settings.conversion_mapping.ldap_to_mo_any.values():
            for mapping in mappings:
                relevant_attributes.update(mapping.ldap_attributes)
        attributes = sorted(relevant_attributes - {"dn"})

        def _run_dirsync() -> tuple[list[dict], bytes]:
            ds = conn.extend.microsoft.dir_sync(
                sync_base=search_base,
                sync_filter=sync_filter,
                attributes=attributes,
                cookie=cookie,
            )
            ds.loop()
            entries = [
                e for e in (conn.response or []) if e["type"] == "searchResEntry"
            ]
            return entries, ds.cookie

        entries, new_cookie = await asyncio.to_thread(_run_dirsync)

        uuids: set[LDAPUUID] = set()
        for entry in entries:
            uuid = entry["attributes"].get(unique_id_field)
            if uuid is None:  # pragma: no cover
                logger.warning("Got DirSync entry without uuid", dn=entry.get("dn"))
                continue
            uuids.add(LDAPUUID(uuid))

        return uuids, new_cookie

    async def _poller_loop(self) -> None:
        """Poll the LDAP server continuously every ``settings.poll_time`` seconds."""
        logger.info("DirSync poller started")
        while True:
            await asyncio.shield(self._generate_events())
            # Wait for a while before running again
            await asyncio.sleep(self.settings.poll_time)

    async def _generate_events(self) -> None:
        # Ensure that a singleton state row exists
        # We do creates separately to support update locks in normal operation
        async with self.sessionmaker() as session, session.begin():
            state = await session.scalar(select(DirSyncState).with_for_update())
            state = state or DirSyncState()
            session.add(state)

        async with self.sessionmaker() as session, session.begin():
            # Get DirSync state from database for updating
            state = await session.scalar(select(DirSyncState).with_for_update())
            assert state is not None

            # Fetch changes and emit events for them
            uuids, new_cookie = await self.poll(state.cookie)

            # Only publish events when there are actual changes
            # DirSync returns an empty set when no changes have occurred
            if uuids:
                await publish_uuids(self.settings, self.graphql_client, list(uuids))

            # Always update the cookie to advance the DirSync position
            state.cookie = new_cookie
            session.add(state)
