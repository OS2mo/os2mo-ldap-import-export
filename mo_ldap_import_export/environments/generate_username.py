# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import re
import string
from collections.abc import Iterator
from contextlib import suppress
from functools import partial
from itertools import groupby
from typing import cast
from uuid import UUID

import structlog
from ldap3 import NO_ATTRIBUTES
from ldap3 import SUBTREE
from ldap3 import Connection
from more_itertools import first
from more_itertools import flatten
from more_itertools import ilen

from ..autogenerated_graphql_client.input_types import ITSystemFilter
from ..autogenerated_graphql_client.input_types import ITUserFilter
from ..config import Settings
from ..config import UsernameGeneratorConfig
from ..dataloaders import DataLoader
from ..exceptions import NoObjectsReturnedException
from ..ldap import LDAPConnection
from ..moapi import MOAPI
from ..models import Employee
from ..types import EmployeeUUID
from ..usernames import generate_person_name
from ..utils import remove_vowels

logger = structlog.stdlib.get_logger()


async def _mo_allows_username(
    moapi: MOAPI,
    username_generator_settings: UsernameGeneratorConfig,
    employee_uuid: EmployeeUUID,
    username: str,
) -> bool:
    # Check if MO allows the username to be used

    # If we are not limiting by mo usernames, the answer is yes, mo allows all
    if not username_generator_settings.disallow_mo_usernames:
        logger.debug("Not configured to check for disallowed MO usernames")
        return True

    # Otherwise, we gotta check if the username is already taken in MO
    #
    # We have to check both past, present and future usernames to ensure no reuse
    # of usernames is ever done. This works as we never actually delete usernames
    # from MO's database, but rather just terminate by putting end-dates on them.
    #
    # We need to block these usernames from being generated, because it is possible
    # that MO generates a user, which is deleted from AD some years later. In that
    # case we should never generate the username of the deleted user.
    # Reference: https://redmine.magenta-aps.dk/issues/57043

    itsystem_user_key = username_generator_settings.existing_usernames_itsystem

    # The username is taken iff there exists atleast one validity in MO where:
    # * The username is set in the user-key
    # * The it-system is our usernames it-system
    result = await moapi.graphql_client.read_filtered_itusers(
        filter=ITUserFilter(
            itsystem=ITSystemFilter(user_keys=[itsystem_user_key]),
            # NOTE: We actually could check a list of candidate usernames here easily
            user_keys=[username],
            # We check all validities; past, present and future
            from_date=None,
            to_date=None,
        )
    )
    logger.debug("Checked for disallowed MO usernames", result=result)
    # None reserves the name, so we can use it
    if not result.objects:
        logger.debug("Username not reserved in MO")
        return True
    # The name is reserved by atleast one user
    # But maybe that user is us, in which case we may be able to reuse it
    if username_generator_settings.reuse_old_usernames:
        # Construct a set of Employee UUIDs which reserve the username
        reserving_employee_uuids = {
            EmployeeUUID(validity.employee_uuid)
            for obj in result.objects
            for validity in obj.validities
            if validity.employee_uuid is not None
        }
        logger.debug(
            "Username reserved in MO, but potentionally allowed for reuse",
            employee_uuid=employee_uuid,
            reserving_employee_uuids=reserving_employee_uuids,
        )
        # We can reuse the username if we are the only employee reserving it
        return {employee_uuid} == reserving_employee_uuids

    # If we get here, the name was reserved, and we could not reuse it
    # Thus MO cannot allow it to be used
    logger.debug("Username reserved in MO")
    return False


async def _ldap_allows_username(
    ldap_connection: Connection, settings: Settings, username: str
) -> bool:
    match settings.ldap_dialect:
        case "Standard":
            # "uid" is the default login field since RFC2798 (inetOrgPerson)
            # (replacing the "userid" term from RFC1274 (COSINE schema))
            # It is the standard LDAP login name field.
            # The Microsoft Active Directory equivalent is sAMAccountName
            search_filters = [f"(uid={username})"]
        case "AD":  # pragma: no cover
            search_filters = [
                f"(sAMAccountName={username})",
                f"(userPrincipalName={username}@*)",
            ]
        case _:  # pragma: no cover
            raise AssertionError("Unknown LDAP dialect")

    for search_filter in search_filters:
        response, result = await LDAPConnection(
            ldap_connection, read_only=True, add_objects_to_ldap=False
        ).ldap_search(
            search_base=settings.ldap_search_base,
            search_filter=search_filter,
            attributes=NO_ATTRIBUTES,
            search_scope=SUBTREE,
            size_limit=1,
        )
        if result["type"] != "searchResDone":  # pragma: no cover
            logger.warning(
                "LDAP connection search returned unexpected result type",
                response=response,
                result=result,
            )
            raise ValueError("Unexpected search result type")
        if result["description"] != "success":  # pragma: no cover
            logger.warning(
                "LDAP connection did not search sucessfully",
                response=response,
                result=result,
            )
            raise ValueError("Search failed")
        # The format of Response is specified in RFC4511 (Section 4.5.2 - Search Result)
        #
        # Response is a list of zero or more SearchResultEntry and/or
        # SearchResultReference messages, followed by a single SearchResultDone message.
        #
        # The SearchResultEntry is a search match, while the SearchResultReference is a
        # continuation search that must be executed by the client, finally the
        # SearchResultDone is an indicator that the search has completed and that no
        # more work needs to be done by the client.
        #
        # The LDAP3 library handles the SearchResultDone message for us by consuming the
        # search result until all results have been collected, it also usually handles
        # the SearchResultReference messages by emitting additionally searches for each
        # reference such that all references are handled.
        #
        # As such we generally expect to only see SearchResultEntry messages in our
        # response, however as the LDAP3 library cannot handle all of Active Directorys
        # shenanigans, so we will sometimes see leftover SearchResultReferences in our
        # response, but we have opted to just ignore these for now.

        # Filter out Active Directory SearchResultReferences that LDAP3 could not handle
        results = [result for result in response if result["type"] == "searchResEntry"]
        # If we got any results, we have found a conflict
        if results:
            return False

    return True


def _create_from_combi(name_parts: list[str], combi: str) -> str | None:
    """Create a username from a name and a combination.

    Args:
        name_parts: An array of names; given_name, middlenames, surname.
        combi: Combination to create a username from. For example "F123LX".

    Raises:
        AssertionError: If an invalid character is provided as combi.

    Returns:
        A username generated according to the combination.
        Note that this username may still contain 'X' characters, which need
        to be replaced with a number.
    """

    def char2namepart(combi_char: str) -> str:
        """Convert combi character to corresponding name part.

        Args:
            combi_char: The character to lookup (One of "F", "L", [1-9])

        Raises:
            ValueError: If the captured name_parts has less than 2 entries.
            IndexError: If an integer higher than the number of middlenames is used.
            AssertionError: If an invalid character is provided as combi_char.

        Returns:
            The name part corresponding to the combi character.
        """
        assert combi_char in {"F", "L"} | {str(x) for x in range(1, 10)}

        given_name, *middlenames, surname = name_parts
        match combi_char:
            case "F":
                return given_name
            case "L":
                return surname
            case x:
                index = int(x) - 1
                return middlenames[index]

    def group2string(combi_char: str, count: int) -> str:
        """Construct a username substring from a group (combi_char + count).

        Args:
            combi_char: The character to lookup (One of "X", "F", "L", [1-9])
            count: The number of characters to extract from the combi_char source.

        Raises:
            ValueError: If a referenced name_part does not have enough characters.
            ValueError: If the captured name_parts has less than 2 entries.
            IndexError: If an integer higher than the number of middlenames is used.
            AssertionError: If an invalid character is provided as combi_char.

        Returns:
            The constructed username substring.
        """
        if combi_char == "X":
            return "X" * count
        name_part = char2namepart(combi_char).lower()
        # Sanity check that the name is long enough
        # Without this check we risk making too short usernames
        if count > len(name_part):
            raise ValueError("Name part too short")
        return name_part[:count]

    # Split code into groups on changes
    # For example "FF1LL" returns [("F",2), ("1",1), ("L",2)]
    groups = [(key, ilen(group)) for key, group in groupby(combi)]

    with suppress(IndexError, ValueError):
        username_parts = [group2string(char, count) for (char, count) in groups]
        return "".join(username_parts)
    return None


def _name_fixer(
    char_replacement: dict[str, str], do_remove_vowels: bool, name_parts: list[str]
) -> list[str]:
    """Cleanup a structured name to remove non-ascii characters.

    Context:
        char_replacement:
            Dictionary from one set of characters to their replacements.

    Args:
        name_parts: An array of names; given_name, middlenames, surname.

    Returns:
        `name_parts` where non-ascii characters have been replaced
        according to the char_replacement map, or if unmatched, removed.
    """

    def fix_name(name: str) -> str:
        # Replace according to replacement list
        for char, replacement in char_replacement.items():
            name = name.replace(char, replacement)
        # Remove all remaining characters outside a-z
        return re.sub(r"[^a-z]+", "", name.lower())

    def eliminate_vowels_from_surnames(name_parts: list[str]) -> list[str]:
        # Remove vowels from all but first name
        # Reference: https://redmine.magenta-aps.dk/issues/56080
        first_name, *lastnames = name_parts
        return [first_name] + [remove_vowels(n) for n in lastnames]

    name_parts = [fix_name(x) for x in name_parts]
    if do_remove_vowels:
        name_parts = eliminate_vowels_from_surnames(name_parts)
    return name_parts


async def _create_username(
    settings: Settings,
    ldap_connection: Connection,
    moapi: MOAPI,
    employee_uuid: EmployeeUUID,
    name: list[str],
) -> str:
    """
    Create a new username in accordance with the rules specified in the json file.
    The username will be the highest quality available and the value will be
    added to list of used names, so consequtive calles with the same name
    will keep returning new names until the algorithm runs out of options
    and a RuntimeException is raised.

    :param name: Name of the user given as a list with at least two elements.
    :return: New username generated.

    Inspired by ad_integration/usernames.py
    """
    username_generator_settings = settings.conversion_mapping.username_generator
    forbidden_usernames = username_generator_settings.forbidden_usernames
    logger.debug("Found forbidden usernames", count=len(forbidden_usernames))

    def permutations(username: str) -> Iterator[str]:
        # The permutation is a number inside the username, it is normally only used in
        # case a username is already occupied. It can be specified using 'X' in the
        # username template.
        #
        # The first attempted permutation should be '2':
        # For example; If 'cvt' is occupied, a username 'cvt2' will be generated.
        #
        # The last attempted permutation is '9' - because we would like to limit the
        # permutation counter to a single digit.
        if "X" in username:
            for permutation_counter in range(2, 10):
                yield username.replace("X", str(permutation_counter))
        else:
            yield username

    def forbidden(username: str) -> bool:
        # Check if core username is legal
        return username.replace("X", "") in forbidden_usernames

    # Cleanup names
    clean_name = _name_fixer(
        username_generator_settings.char_replacement,
        username_generator_settings.remove_vowels,
        name,
    )
    logger.debug(
        "Cleaned name for username generation", name=name, clean_name=clean_name
    )

    combinations = username_generator_settings.combinations_to_try
    for combination in combinations:
        # Generate usernames from clean_name and combination
        username = _create_from_combi(clean_name, combination)
        username_logger = logger.bind(combination=combination, username=username)
        username_logger.debug("Username candidate generated")

        if username is None:
            username_logger.debug("Rejecting empty username")
            continue

        if forbidden(username):
            username_logger.debug("Rejecting forbidden username")
            continue

        p_usernames = permutations(username)
        for p_username in p_usernames:
            permutation_logger = username_logger.bind(permutation=p_username)
            permutation_logger.debug("Username permutation generated")

            if not await _ldap_allows_username(ldap_connection, settings, p_username):
                permutation_logger.debug(
                    "Rejecting username candidate due to existing LDAP usage"
                )
                continue

            if not await _mo_allows_username(
                moapi, username_generator_settings, employee_uuid, p_username
            ):
                permutation_logger.debug(
                    "Rejecting username candidate due to disallowed MO usernames"
                )
                continue

            return p_username

    # TODO: Return a more specific exception type
    raise RuntimeError("Failed to create user name.")


async def generate_username_func(
    settings: Settings, ldap_connection: Connection, moapi: MOAPI, employee: Employee
) -> str:
    name = generate_person_name(employee)
    username = await _create_username(
        settings, ldap_connection, moapi, EmployeeUUID(employee.uuid), name
    )
    logger.info("Generated username based on name", name=name, username=username)
    return username


async def generate_username(
    dataloader: DataLoader,
    employee_uuid: UUID,
) -> str:
    employee = await dataloader.moapi.load_mo_employee(employee_uuid)
    if employee is None:  # pragma: no cover
        raise NoObjectsReturnedException(f"Unable to lookup employee: {employee_uuid}")
    return cast(
        str,
        await generate_username_func(
            dataloader.settings,
            dataloader.ldapapi.connection,
            dataloader.moapi,
            employee,
        ),
    )


def _extract_letters(name: list[str]) -> list[str]:
    length = 3
    max_iterations = 1000

    # Convert ["Firstname", "Last Name"] -> ["Firstname", "Last", "Name"]
    # and ["First-Name", "Last-Name"] -> ["First", "Name", "Last", "Name"]
    name = flatten(map(partial(re.split, r"[\-\s+]"), name))  # type: ignore

    # Convert all name parts to lowercase
    name = [x.lower() for x in name]

    # Check name parts
    ascii_lowercase_set = set(string.ascii_lowercase)
    # We assume that name has atleast a given_name
    first_ascii_letter = first(
        (c for c in first(name) if c in ascii_lowercase_set), None
    )
    assert (
        first_ascii_letter is not None
    ), "first name part must contain at least one ASCII letter"

    # Take first letter of first name part (regardless of whether it is a vowel or
    # a consonant.)
    result = [first_ascii_letter]

    consonants = ascii_lowercase_set - set("aeiouy")

    def strip_vowels(part: str) -> str:
        return "".join(ch for ch in part if ch.lower() in consonants)

    consonant_name = [strip_vowels(part) for part in name]

    # Continue at first letter of the second name part (first part if only one part)
    p = min(1, len(consonant_name) - 1)  # second name part (or first if only one part)
    offset = 0  # = first letter

    iterations = 0
    while len(result) < length:
        part = consonant_name[p]
        try:
            result.append(part[offset])
        except IndexError:
            # Check if there are still more name parts to use
            if p < len(consonant_name) - 1:
                # If yes, use next name part, starting at first letter
                p += 1
                offset = 0
            else:
                # If no, go back to first name
                p = 0
        else:
            offset += 1

        iterations += 1
        if iterations > max_iterations:
            raise ValueError(f"cannot create username for input {name!r}")

    return result


class UserNameGenPermutation:
    def __init__(self):
        self.occupied_names = set()
        self._loaded_occupied_name_sets = []

    def add_occupied_names(self, occupied_names: set) -> None:
        self.occupied_names.update(set(occupied_names))
        self._loaded_occupied_name_sets.append(occupied_names)

    def is_username_occupied(self, username):
        return username.lower() in set(map(str.lower, self.occupied_names))

    def create_username(self, name: list[str]) -> str:
        suffix = 1
        while True:
            letters = _extract_letters(name)
            new_username = "%s%d" % ("".join(letters), suffix)
            if not self.is_username_occupied(new_username):
                # An unused username was found, add it to the list of
                # occupied names and return.
                self.occupied_names.add(new_username)
                return new_username
            else:
                # We are still looking for an available username.
                # Bump the `suffix` variable.
                suffix += 1
